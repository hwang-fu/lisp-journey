<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Common Lisp</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    table {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>Common Lisp</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How to use SBCL?</h3>
<ol>
    <li>To run a <i>.lisp</i> or <i>.lsp</i> file:<br/><br/>
        <code>sbcl --script &lt;filename&gt;</code></li>
    <br/>
    <br/>
    <li>To load a <i>.lisp</i> or <i>.lsp</i> file:<br/><br/>
        <code>sbcl --load &lt;filename&gt;</code></li>
    <br/>
    <br/>
    <li>To load a <i>.lisp</i> or <i>.lsp</i> file inside the SBCL prompt:<br/><br/>
        <code>* (load "hello.lisp")</code></li>
    <br/>
    <br/>
    <li>To quit inside the SBCL prompt:<br/><br/>
        <code>* (quit)</code><br/>
        <code>* (sb-ext:quit)</code></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Hello World in Common Lisp</h3>
<ol>
    <li>Genre 1:<br/><br/>
        <code>(write-line "Hello World!")</code>
    </li>
    <br/>
    <br/>
    <li>Genre 2:
<pre><code class="language-lisp line-numbers">(defun hello-world()
    (format t "Hello World!"))

(hello-world)
</code></pre>
    </li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Lisp Uses Prefix Notation</h3>
<ol>
    <li>In prefix notation, operators are written before their operands.</li>
<pre><code class="language-lisp line-numbers">a * (b + c) / d
(/ (* a (+ b c)) d)
</code></pre>
<br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basic Building Blocks in Lisp</h3>
<ol>
    <li>Lisp programs are made of three basic building blocks.</li>
    <br/>
    <ul>
        <li>atom</li>
        <br/>
        <li>list</li>
        <br/>
        <li>string</li>
        <br/>
    </ul>
    <br/>
    <br/>
    <li>An <b>atom</b> is a number or a string of contiguous characters.</li>
<pre><code class="language-lisp line-numbers">hello-from-lisp
12300009
*hello*
block#123
abc123
</code></pre>
    <br/>
    <br/>
    <li>A <b>list</b> is a sequence of atoms and other lists enclosed in parentheses.</li>
<pre><code class="language-lisp line-numbers">(this is a list)
(a (a b c) d e f)
(Sun Mon Tue Wed Thu Fri Sat)
( )
</code></pre>
    <br/>
    <br/>
    <li>A <b>string</b> is a group of characters enclosed in double quotation mark ( " )</li>
<pre><code class="language-lisp line-numbers">"here is a string"
"hello"
"Please enter a number:"
" "
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Comments</h3>
<ol>
    <li>The semicolon <code>;</code> indicates a line-comment.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Macro</h3>
<ol>
    <li>Technically, a macro is a function that takes an s-expression as arguments and returns a Lisp form, which is then evaluated.</li>
    <br/>
    <br/>
    <li>Syntax for defining a named macro:</li>
<pre><code class="language-lisp line-numbers">(defmacro &lt;macro-name&gt; (&lt;param-list&gt;)
  "optional document string."
  &lt;body&gt;)
</code></pre>
    <br/>
    <br/>
    <li>Backquote Examples:</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Backquote Syntax</th>
            <th>Equivalent List-Building Code</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>`(a (+ 1 2) c)</code></td>
            <td><code>(list 'a '(+ 1 2) 'c)</code></td>
            <td><code>(a (+ 1 2) c)</code></td>
        </tr>
        <tr>
            <td><code>`(a ,(+ 1 2) c)</code></td>
            <td><code>(list 'a (+ 1 2) 'c)</code></td>
            <td><code>(a 3 c)</code></td>
        </tr>
        <tr>
            <td><code>`(a (list 1 2) c)</code></td>
            <td><code>(list 'a '(list 1 2) 'c)</code></td>
            <td><code>(a (list 1 2) c)</code></td>
        </tr>
        <tr>
            <td><code>`(a ,(list 1 2) c)</code></td>
            <td><code>(list 'a (list 1 2) 'c)</code></td>
            <td><code>(a (1 2) c)</code></td>
        </tr>
        <tr>
            <td><code>`(a ,@(list 1 2) c)</code></td>
            <td><code>(append (list 'a) (list 1 2) (list 'c))</code></td>
            <td><code>(a 1 2 c)</code></td>
        </tr>
    </tbody>
</table>
    <br/>
    <br/>
    <br/>
    <li>Syntax: <code>defmacro &lt;macro-name&gt; (&lt;lambda-list&gt; [&lt;doc-string&gt;] [&lt;decl&gt;]* &lt;form&gt;*)</code></li>
    <ul>
        <br/>
        <li><i>defmacro</i>: The defining keyword.</li>
        <br/>
        <li><i>macro-name</i>: The name of the macro (a symbol).</li>
        <br/>
        <li><i>lambda-list</i>:The parameter list, receives un-evaluates forms. Also supports &amp;optional, &amp;key like in the <b>DEFUN</b>.<br/>
            But in <b>DEFMACRO</b> &amp;rest is usually not used, instead &amp;body is represented as the body form.</li>
        <br/>
        <li><i>doc-string</i>: Optional. String shown by <b>DOCUMENTATION</b>.</li>
        <br/>
        <li><i>decl</i>: Compiler decalarations.</li>
        <br/>
        <li><i>form</i>: The body. Must return code (a Lisp form), not run the code.</li>
    </ul>
    <br/>
    <br/>
    <li>Example:</li>
<pre><code class="language-lisp line-numbers">(defmacro my-when (test &amp;body body)
  "If TEST is true, execute BODY like (progn ...)."
  `(if ,test
       (progn ,@body)))

(my-when (&gt; x 10)
  (print "positive")
  (incf x))

;; Macro expansion (what Lisp actually sees):
(if (&gt; x 0)
  (progn (print "positive") (incf x)))
</code></pre>
    <br/>
    <br/>
    <li>More advanced example(s):</li>
<pre><code class="language-lisp line-numbers">(defmacro echo-times (&amp;body body &amp;key (times 1) (prefix "=&gt; "))
  ;; Remove trailing keyword/value pairs from BODY so we only keep real forms.
  (let* ((rev (reverse body))
         (pure-rev
           (loop with lst = rev
                 ;; While the reversed list starts with a keyword/value pair,
                 ;; drop those two cells.
                 while (and (consp lst) (consp (cdr lst)) (keywordp (car lst)))
                 do (setf lst (cddr lst))
                 finally (return lst)))
         (pure-body (reverse pure-rev)))
    `(dotimes (i ,times)
       (format t "~A" ,prefix)
       (progn ,@pure-body))))

(echo-times
  (format t "Hello~%")
  (format t "World~%")
  :times 2
  :prefix "[*] ")


;; --------------------------


(defmacro with-prefix ((&amp;key (prefix "=&gt; ") (times 1)) &amp;body body)
  `(dotimes (i ,times)
     (format t "~A" ,prefix)
     (progn ,@body)))

(with-prefix (:prefix "[*] " :times 2)
  (format t "Hello~%")
  (format t "World~%"))
</code></pre>
    <br/>
    <br/>
    <li>The <i>declaration</i> part of <b>DEFMACRO</b>: Will be covered in the future...</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Variables</h3>
<ol>
    <li>Global variables are generally declared using the <code>DEFVAR</code> construct.</li>
<pre><code class="language-lisp line-numbers">; Define a global variable x with a value of `100`
(defvar x 100)
; Print the value of `x`
(print x)
</code></pre>
    <br/>
    <br/>
    <li>If there is no type declaration for variables in Lisp, you can directly specify a value for a symbol with the <code>SETQ</code> construct.</li>
    <br/>
    <br/>
    <li>There are two constructs: <code>LET</code> and <code>PROG</code> (no longer commonly used) for creating local variables.</li>
    <br/>
    <br/>
    <li>The <code>LET</code> construct has the following syntax.<br/>
        If you did NOT include an initial value for a variable, it is assigned <code>NIL</code>.</li>
<pre><code class="language-lisp line-numbers">(let ((var-1 val-1) (var-2 val-2) ... (var-n val-n))
  &lt;s-expression&gt;
  &lt;s-expression&gt;
  ...)
</code></pre>
    <br/>
    <br/>
    <li>The <code>PROG</code> construct has the following syntax.</li>
<pre><code class="language-lisp line-numbers">(prog (var-1 var-2 ... var-n)
  &lt;s-expression&gt;
  &lt;s-expression&gt;
  ...)
</code></pre>
    <br/>
    <br/>
    <li>Common Lisp supports <u>variable shadowing</u>.</li>
    <br/>
    <br/>
    <li>Common Lisp provides two ways to create global variables:
        <b>DEFVAR</b> and <b>DEFPARAMETER</b>.<br/>
        Both forms take a variable <i>name</i>, an initial <i>value</i>, and an <i>optional documentation string</i>.</li>
    <br/>
    <br/>
    <li>Global variables are conventionally named with names that start and end with <code>*</code> (e.g., <code>*db*</code>).</li>
<pre><code class="language-lisp line-numbers">(defvar *count* 0
  "Count of widgets made so far.")

(defparameter *gap-tolerance* 0.001
  "Tolerance to be allowed in widget gaps.")
</code></pre>
    <br/>
    <br/>
    <li><b>DEFCONSTANT</b> defines a named global constant.</li>
<pre><code class="language-lisp line-numbers">(sbcl) (defconstant +pi+ 3.1415926 "Approximation of PI")
(sbcl) +pi+
    3.1415926
</code></pre>
    <br/>
    <br/>
    <li><b>SETF</b> is the general-purpose <u>assignment operator</u> in Common Lisp.<br/>
        It is used to set or update the value of variables, places (like array elements, object fields, etc.), and more.<br/>
        <br/><code>(setf place value)</code></li>
    <br/>
    <br/>
    <li><b>SETF</b> can also assign to multiple places in sequence.</li>
<pre><code class="language-lisp line-numbers">(setf x 1)
(setf y 1)

(setf x 1 y 2)
</code></pre>
    <br/>
    <br/>
    <li><b>SETF</b> returns the newly assigned value,<br/>
        so you can also nest calls to <b>SETF</b> as in the following expression, which assigns both <i>x</i> and <i>y</i> the same random value: <code>(setf x (setf y (random 10)))</code></li>
    <br/>
    <br/>
    <li>You could increment / decrement a number with <b>SETF</b>:</li>
<pre><code class="language-lisp line-numbers">(setf x (+ x 1));   (incf x)
(setf x (+ x 10));  (incf x 10)
(setf x (- x 1));   (decf x)
</code></pre>
    <br/>
    <br/>
    <li><b>ROTATEF</b>: swaps values in-place by rotating them left-wise, returns <b>NIL</b>.<br/>
        <mark>NOTE</mark>: All places (variables, array elements, etc.) must be writable with <b>SETF</b>.</li>
<pre><code class="language-lisp line-numbers">(rotatef &lt;place1&gt; &lt;place2&gt; ... &lt;placeN&gt;)

place1 &lt;- place2
place2 &lt;- place3
...
placeN &lt;- original place1

(let ((a 1) (b 2) (c 3))
  (rotatef a b c)
  (list a b c))

(2 3 1)
</code></pre>
    <br/>
    <br/>
    <li><b>SHIFTF</b> shifts values left-wise and returns the original first value.</li>
<pre><code class="language-lisp line-numbers">(shiftf &lt;place1&gt; &lt;place2&gt; ... &lt;placeN&gt; &lt;new-value&gt;)

place1 &lt;- place2
place2 &lt;- place3
...
placeN &lt;- new-value
return &lt;- original place1

(let ((a 1) (b 2) (c 3))
  (shiftf a b c 100))       ;; returns 1
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Difference between <code>LET</code> and <code>LET*</code></h3>
<ol>
    <li><code>LET</code>: All variables are initialized in parallel.</li>
    <br/>
    <br/>
    <li><code>LET*</code>:
        Variables are initialized one by one in sequence,
        left to right, and each one can use the previous ones.</li>
<pre><code class="language-lisp line-numbers">(let* ((a 2)
       (b (+ a 3))      ; b = 2 + 3 = 5
       (c (* b 4)))     ; c = 5 * 4 = 20
  (list a b c))         ; (2 5 20)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Difference between <code>DEFVAR</code> and <code>DEFPARAMETER</code></h3>
<ol>
    <li><code>DEFVAR</code>: re-decl does not overwrite an existing value (can be later changed with assignment).</li>
<pre><code class="language-lisp line-numbers">(sbcl) (defvar *x* 10)
(sbcl) (defvar *x* 20)
(sbcl) *x*
    10
</code></pre>
    <br/>
    <br/>
    <li><code>DEFPARAMETER</code>: re-decl always resets the value.</li>
<pre><code class="language-lisp line-numbers">(sbcl) (defparameter *x* 10)
(sbcl) (defparameter *x* 20)
(sbcl) *x*
    20
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Escape Character</h3>
<ol>
    <li>A backslash ( <code>\</code> ) escapes the next character, causing it to be included in the string regardless of what it is.</li>
<pre><code class="language-lisp line-numbers">"foo"       ; foo
"f\oo"      ; foo,  because `\o` escapes `o`, treating it iterally like the character `o`.
"fo\\o"     ; fo\o
"fo\'o"     ; fo'o
"fo\"o"     ; fo"o
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Symbol</h3>
<ol>
    <li>There are 10 characters that serve other syntactic purposes can NOT appear in names:</li>
    <br/>
    <ul>
        <li>Open Parentheses (<code> ( </code>)</li>
        <br/>
        <li>Close Parentheses (<code> ) </code>)</li>
        <br/>
        <li>Double Quote (<code> " </code>)</li>
        <br/>
        <li>Single Quote (<code> ' </code>)</li>
        <br/>
        <li>Backtick (<code> ` </code>)</li>
        <br/>
        <li>Comma (<code> , </code>)</li>
        <br/>
        <li>Colon (<code> : </code>)</li>
        <br/>
        <li>Semicolon (<code> ; </code>)</li>
        <br/>
        <li>Backslash (<code> \ </code>)</li>
        <br/>
        <li>Vertical Bar (<code> | </code>)</li>
        <br/>
    </ul>
    <br/>
    <li>If you really want to use those character,
        try to escape them with a backslash (<code> \ </code>)<br/>
        or surround the part of the name containing characters that need escaping
        with vertical bars (<code> | </code>).</li>
<pre><code class="language-lisp line-numbers">
    (defun test\,-lisp ()
      (write-line "Hello, world!"))
    (test\,-lisp)

    (defun |test,-lisp| ()
      (write-line "Hello, world!"))
    (|test,-lisp|)

    (defun | test,-lisp | ()
      (write-line "Hello, world!"))
    (| test,-lisp |)
</code></pre>
    <br/>
    <br/>
    <li><mark>NOTE</mark>:
        The symbol names are <u>case-insensitive</u>,
        it converts all unescaped characters to upper case,
        like <i>foo</i>, <i>Foo</i>, and <i>FOO</i> are the same.<br/>
        However, the f\o\o and |foo| will preserve the case, they are read as <i>foo</i>.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Keyword Symbols</h3>
<ol>
    <li>Keyword symbols are prefixed with a colon (e.g., <code>:name</code>, <code>:id</code>).<br/><br/>
        This prefix automatically makes them part of the <b>KEYWORD</b> package.</li>
    <br/>
    <br/>
    <li>Unlike regular symbols, keyword symbols <u>evaluate to themselves</u>.</li>
<pre><code class="language-lisp line-numbers">&gt; :example
:EXAMPLE

&gt; :EXample
:EXAMPLE

&gt; :\example
:|eXAMPLE|

&gt; :a\,b
:|A,B|

&gt; :123
:|123|

&gt; :123abc
:123ABC

&gt; :abc123
:ABC123

&gt; :|xyz|
:|xyz|
</code></pre>
    <br/>
    <br/>
    <li>Keyword symbols are often used as keys in property list.</li>
<pre><code class="language-lisp line-numbers">&gt; (setq person '(:name "Alice" :age 20))
&gt; (getf person :name)
"Alice"
; Btw, (setq person (:name "Alice" :age 20)) is invalid, because Lisp will tru to eval as if :name were a function.
; You can also use (setq person (list :name "Alice" :age 20)) instead.
</code></pre>
    <br/>
    <br/>
    <li>Many libraries use keyword symbols for configuration settings.</li>
<pre><code class="language-lisp line-numbers">(open "settings.conf", :direction :output)</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3><u>if</u> Statement</h3>
<ol>
    <li>Syntax:<code> (if &lt;cond&gt; &lt;then&gt; [&lt;else&gt;]) </code></li>
    <br/>
    <ul>
        <li><i>cond</i> is a condition that eval to either NIL (false) or non-NIL (true).</li>
        <br/>
        <li><i>then</i> is the expression to exec if <i>cond</i> is true.</li>
        <br/>
        <li><i>else</i> is the optional expression to exec if <i>cond</i> is false.</li>
        <br/>
    </ul>
    <br/>
    <br/>
    <li>Basic Example:</li>
<pre><code class="language-lisp line-numbers">(if (&gt; 10 5)
  (write-line "10 &gt; 5")
  (write-line "10 &lt;= 5"))
</code></pre>
    <br/>
    <li>Without <i>else</i> expression:</li>
<pre><code class="language-lisp line-numbers">(if (= 1 1) (write-line "1 equals 1"))</code></pre>
    <br/>
    <br/>
    <li>Nested <i>if</i>: </li>
<pre><code class="language-lisp line-numbers">(if (&gt; 10 5)
  (if (&lt; 3 4)
    (write-line "10 &gt; 5 and 3 &lt; 4")
    (write-line "10 &gt; 5 and 3 &gt;= 4"))
  (write-line "10 &lt;= 5"))
</code></pre>
    <br/>
    <br/>
    <li>The <i>if</i> expression returns the result of the evaluated <i>then</i> or <i>else</i> form.</li>
<pre><code class="language-lisp line-numbers">(let ((x 10))
  (if (&gt; x 5) (+ x 10) (- x 10)))
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about <u>quote</u></h3>
<ol>
    <li>It is used to prevent an expression from being evaluated.</li>
    <br/>
    <br/>
    <li>Syntax:
        <code>(quote &lt;expr&gt;)</code> or shorthandly <code>'&lt;expr&gt;</code></li>
    <br/>
    <br/>
    <li>Example Usage:</li>
<pre><code class="language-lisp line-numbers">&gt; (quote (+ 1 2))
(+ 1 2)
&gt; '(+ 1 2)
(+ 1 2)
&gt; (+ 1 2)
3

&gt; 'a
A
&gt; '\a
|a|


&gt; (setq a 100)
100
&gt; a
100
&gt; 'a
A
&gt; (symbol-value 'a)
100


&gt; (setq a 'b)   ; a holds the symbol B
B
&gt; (set a 100)   ; same as (set 'b 100)
100
&gt; b
100
</code></pre>
    <br/>
    <br/>
    <li><code>(setq a 100)</code> and <code>(setq 'a 100)</code> are NOT the same
        (<b>SETQ</b> expects an unquoted symbol in the variable position).</li>
    <br/>
    <br/>
    <li>
        If you want to assign to a variable by a symbol at runtime, use the symbol's value cell:
        <code>(setf (symbol-value 'a) 100)</code> or <code>(set 'a 100)</code>
    </li>
    <br/>
    <br/>
    <li><code>'a</code> is a symbol ONLY when evaluated, normally it is treated as an quoted expression <code>(quote A)</code>.</li>
    <br/>
    <br/>
    <li>Quick contrasts:</li>
    <ul>
        <br/>
        <li><code>(setq a 100)</code>: special operator; does NOT evaluate the variable name; sets the variable <code>A</code>.</li>
        <br/>
        <li><code>(setf a 100)</code>: for simple variables same as <b>SETQ</b>.</li>
        <br/>
        <li><code>(set 'a 100)</code>: function; evaluates <code>'a</code> to <code>A</code>; sets <code>A</code>'s global/special value cell.</li>
        <br/>
        <li><code>(set a 100)</code>: function; evaluates <code>a</code> (must be a symbol); sets that symbol's global/special value.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>True, False and Equality</h3>
<ol>
    <li>The symbol <b>t</b> or <b>T</b> is conventionally treated as true in Common Lisp.<br/><br/>
        <code>(if t "True" "False")</code><code class="hl-grey-fg"> ; returns "True"</code></li>
    <br/>
    <br/>
    <li>The expressions <b>nil</b>, <b>'nil</b>, <b>()</b> and <b>'()</b> are considered false in Common Lisp.<br/><br/>
        <code>(if nil "T" "F")</code><code class="hl-grey-fg"> ; returns "F"</code><br/>
        <code>(if () "T" "F")</code><code class="hl-grey-fg"> ; returns "F"</code><br/>
    </li>
    <br/>
    <br/>
    <li><b>EQ</b> checks whether two values are literally the same object: the same address, same identity.</li>
<pre><code class="language-lisp line-numbers">(eq 1000 1000)   ;; might be NIL on some Lisps
(eq 'foo 'foo)   ;; always T (same interned symbol)
</code></pre>
    <br/>
    <br/>
    <li><b>EQL</b> is just like <b>EQ</b>, but slightly stronger: it also considers numbers and characters with the same value as equal.</li>
<pre><code class="language-lisp line-numbers">(eql 1000 1000)  ;; always T
(eql 1.0 1)      ;; NIL (different types)
(eql #\A #\A)    ;; T
</code></pre>
    <br/>
    <br/>
    <li><b>EQUAL</b> compares structural lists and strings (and bit-vectors).</li>
<pre><code class="language-lisp line-numbers">(equal '(a (b)) '(a (b)))   ;; T
(equal "Foo" "Foo")         ;; T
(equal "Foo" "foo")         ;; NIL (case-sensitive)
(equal 1 1.0)               ;; NIL (numbers must be EQL)
(equal #\A #\a)             ;; NIL
</code></pre>
    <br/>
    <br/>
    <li><b>EQUALP</b> is more forgiving: case-insensitive for strings and characters, and value comparison for numbers.</li>
<pre><code class="language-lisp line-numbers">(equalp "Foo" "foo")        ;; T
(equalp #\A #\a)            ;; T
(equalp 1 1.0)              ;; T
(equalp '(1 "A") #(1 "a"))  ;; T (list vs vector ok; string case ignored)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about <u>cond</u></h3>
<ol>
    <li><b>cond</b> is a versatile conditional construcy used for multi-branch descision-making.
        It is preferred over nested <b>if</b>.</li>
    <br/>
    <br/>
    <li>Syntax:</li>
<pre><code class="language-lisp line-numbers">(cond
  (&lt;cond-1&gt; &lt;form-1-1&gt; &lt;form-1-2&gt; ...)
  (&lt;cond-2&gt; &lt;form-2-1&gt; &lt;form-2-2&gt; ...)
  ...
  (t &lt;default-form-1&gt; &lt;default-form-2&gt; ...))
</code></pre>
    <ul>
        <br/>
        <li><b><i>cond-n</i></b> is a condition</li>
        <br/>
        <li><b><i>form</i></b> is one or more expressions to be executed if <b><i>cond-n</i></b> is true.</li>
        <br/>
        <li><b><i>t</i></b> in the end act as a default case.</li>
        <br/>
        <li><mark>NOTE</mark>: only the first <b><i>cond</i></b> which is eval-ed to true is exec-ed.</li>
    </ul>
    <br/>
    <br/>
    <li>Example Usage:</li>
<pre><code class="language-lisp line-numbers">(defun categorize-number (x)
  (cond
    ((&lt; x 0) "negative")
    ((&gt; x 0) "positive")
    ((= x 0) "zero")))

(categorize-number 10)
(categorize-number -7)
(categorize-number 0)

(defun analyze-number (x)
  (cond
    ((&lt; x 0) (format t "~a &lt; 0~%" x) "negative")
    ((&gt; x 0) (format t "~a &gt; 0~%" x) "positive")
    ((= x 0) (format t "x = 0~%") "zero")))

(analyze-number -3)
; it will "-3 &lt; 0" and return "negative"
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Functions</h3>
<ol>
    <li><b>Defining functions with DEFUN</b></li>
    <br/>
    <ul>
        <li>Functions in Common Lisp are most commonly defined with the <b>DEFUN</b> macro.</li>
        <br/>
        <li>Basic form:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun &lt;function-name&gt; (&lt;parameter-list&gt;)
  "Optional documentation string."
  &lt;function-body&gt;)
</code></pre>
    <br/>
    <ul>
        <li>The function body can contain any number of Lisp expressions,
            the value of the <b>last</b> expression becomes the return value.</li>
        <br/>
        <li>Function names are usually written with hyphens (<code>frob-widget</code>) rather than underscores (<code>frob_widget</code>) or camel case (<code>frobWidget</code>).</li>
        <br/>
    </ul>
<pre><code class="language-lisp line-numbers">(defun verbose-sum (x y)
  "Sum two numbers after printing a message."
  (format t "Summing ~D and ~D.~%" x y)
  (+ x y))
</code></pre>
    <br/>
    <ul>
        <li>Call it normally:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(verbose-sum 2 3)
;; Prints: Summing 2 and 3.
;; Returns: 5
</code></pre>
    <br/>
    <br/>


    <li><b>Documentation strings</b></li>
    <br/>
    <ul>
        <li>If a string literal follows the parameter list, it's stored as the <b>function's docstring</b>.</li>
        <li>You can later retrieve it using <code>(documentation '&lt;function-name&gt; 'function)</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(documentation 'verbose-sum 'function)
;; =&gt; "Sum two numbers after printing a message."
</code></pre>
    <br/>
    <br/>


    <li><b>Required parameters</b></li>
    <br/>
    <ul>
        <li>Parameters listed normally (no prefix) are <b>required</b>.</li>
        <li>If the function is called with too few or too many arguments, Lisp signals an error.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun add-two (a b)
  (+ a b))

(add-two 3 4)  ; =&gt; 7
(add-two 3)    ; =&gt; Error: too few arguments
</code></pre>
    <br/>
    <br/>


    <li><b>Optional parameters (<code>&amp;optional</code>)</b></li>
    <br/>
    <ul>
        <li>After required parameters, you can list <code>&amp;optional</code> parameters that may be omitted.</li>
        <li>If not supplied, they default to <code>NIL</code> (or a custom default you specify).</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun foo (a b &amp;optional c d)
  (list a b c d))

(foo 1 2)      ; =&gt; (1 2 NIL NIL)
(foo 1 2 3)    ; =&gt; (1 2 3 NIL)
(foo 1 2 3 4)  ; =&gt; (1 2 3 4)
</code></pre>
    <br/>
    <ul>
        <li>Each optional parameter can also have:
            <ul>
                <li>a <b>default value</b></li>
                <li>a <b>supplied-p variable</b> (<code>T</code> or <code>NIL</code>)
                    tells if the caller explicitly gave a value (you can also customize your own name for it).</li>
            </ul>
        </li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun bar (a &amp;optional (b 10) (c 20 c-supplied-p))
  (list a b c c-supplied-p))

(bar 1)        ; =&gt; (1 10 20 NIL)
(bar 1 2)      ; =&gt; (1 2 20 NIL)
(bar 1 2 30)   ; =&gt; (1 2 30 T)
</code></pre>
    <br/>
    <ul>
        <li>Optional parameters can depend on previous ones:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun make-rectangle (width &amp;optional (height width))
  (list :width width :height height))

(make-rectangle 10)   ; =&gt; (:WIDTH 10 :HEIGHT 10)
(make-rectangle 10 5) ; =&gt; (:WIDTH 10 :HEIGHT 5)
</code></pre>
    <br/>
    <br/>


    <li><b>Rest parameters (<code>&amp;rest</code>)</b></li>
    <br/>
    <ul>
        <li><code>&amp;rest</code> gathers all remaining arguments into a list.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun sum (&amp;rest nums)
  (reduce #'+ nums :initial-value 0))

(sum)             ; =&gt; 0
(sum 1 2 3 4 5)   ; =&gt; 15
</code></pre>
    <br/>
    <ul>
        <li>The <code>&amp;rest</code> variable always receives a list, even if empty.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Keyword parameters (<code>&amp;key</code>)</b></li>
    <br/>
    <ul>
        <li>After required / optional / rest parameters, you can declare keyword arguments with <code>&amp;key</code>.</li>
        <li>Keyword arguments are passed by name using <code>:&lt;keyword&gt;</code> symbols.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun configure (&amp;key a b c)
  (list a b c))

(configure)                ; =&gt; (NIL NIL NIL)
(configure :a 1)           ; =&gt; (1 NIL NIL)
(configure :b 2)           ; =&gt; (NIL 2 NIL)
(configure :a 1 :c 3)      ; =&gt; (1 NIL 3)
</code></pre>
    <br/>
    <ul>
        <li>You can also specify default values and <code>-supplied-p</code> flags, just like optional parameters.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun foo (&amp;key (a 0) (b 0 b-supplied-p) (c (+ a b)))
  (list a b c b-supplied-p))

(foo)                ; =&gt; (0 0 0 NIL)
(foo :a 1)           ; =&gt; (1 0 1 NIL)
(foo :b 1)           ; =&gt; (0 1 1 T)
(foo :a 2 :b 1 :c 4) ; =&gt; (2 1 4 T)
</code></pre>
    <br/>
    <ul>
        <li>You can define <b>keyword aliases</b> to match external names to internal variable names:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun fruit (&amp;key ((:apple a)) ((:banana b) 0) ((:cherry c) 0 c-supplied-p))
  (list a b c c-supplied-p))

(fruit :apple 10 :banana 20 :cherry 30)
;; =&gt; (10 20 30 T)
</code></pre>
    <br/>
    <br/>


    <li><b>Combining &amp;rest and &amp;key</b></li>
    <br/>
    <ul>
        <li>You can use both together if you want the raw list of keywords as well.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun foo (&amp;rest args &amp;key a b c)
  (list args a b c))

(foo :a 1 :b 2 :c 3)
;; =&gt; ((:A 1 :B 2 :C 3) 1 2 3)
</code></pre>
    <br/>
    <br/>


    <li><b>Returning values</b></li>
    <br/>
    <ul>
        <li>A function returns the value of its last evaluated form.</li>
        <li>You can use <code>RETURN-FROM</code> to exit early with a specific value.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun check (x)
  (if (minusp x)
      (return-from check "negative")
      "non-negative"))

(check 5)   ; =&gt; "non-negative"
(check -2)  ; =&gt; "negative"
</code></pre>
    <br/>
    <ul>
        <li>To return multiple values, use <code>(values ...)</code> (see <b><a href="#multiple-values">Multiple Values</a></b> chapter).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Local functions: FLET and LABELS</b></li>
    <br/>
    <ul>
        <li>You can define helper functions inside another function with <code>flet</code> or <code>labels</code>.</li>
        <li><code>flet</code> defines local functions that cannot recursively call themselves, <code>labels</code> allows recursion.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun example (n)
  (labels ((square (x) (* x x))
           (sum-up (m) (if (zerop m) 0 (+ (square m) (sum-up (1- m))))))
    (sum-up n)))

(example 3) ; =&gt; 14  (1² + 2² + 3²)
</code></pre>
    <br/>
    <br/>


    <li><b>Inspecting and redefining functions</b></li>
    <br/>
    <ul>
        <li>The symbol's function cell stores its definition. You can access it with <code>symbol-function</code>:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(symbol-function 'verbose-sum)
;; =&gt; #&lt;FUNCTION VERBOSE-SUM&gt;
</code></pre>
    <br/>
    <ul>
        <li>You can also attach or change documentation:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(setf (documentation 'verbose-sum 'function)
      "Add two numbers and print a friendly message.")
</code></pre>
    <br/>
    <ul>
        <li>To redefine a function, just call <code>defun</code> again with the same name — the old version will be replaced.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Functions vs variables: separate namespaces</b></li>
    <br/>
    <ul>
        <li>Common Lisp has separate namespaces for <b>functions</b> and <b>variables</b>.</li>
        <li>This means you can have a variable and a function with the same name.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun foo (x) (+ x 1))
(setq foo 42)

foo        ; =&gt; 42       (variable)
(foo 10)   ; =&gt; 11       (function)
</code></pre>
    <br/>
    <br/>


    <li><b>Pure vs impure functions</b></li>
    <br/>
    <ul>
        <li>A function with no side effects (no I/O, no mutation) is called <b>pure</b>.</li>
        <li>Functions like <code>+</code> and <code>*</code> are pure; functions like <code>format</code> or <code>setf</code> have side effects.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun pure-add (x y) (+ x y))

(defvar *count* 0)
(defun impure-add (x y) (incf *count*) (+ x y))
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Function Return Values</h3>
<ol>
    <li><b>Returning from a function</b></li>
    <br/>
    <ul>
        <li>In Common Lisp, a function normally returns the value of the <u>last evaluated expression</u> in its body.</li>
        <li>However, sometimes you want to return early from the middle of the body — similar to <code>return</code> in other languages.</li>
        <li>That's what <code>RETURN-FROM</code> and <code>RETURN</code> are for.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun absolute-value (x)
  (if (minusp x)
      (return-from absolute-value (- x))
      x))

(absolute-value -10) ; =&gt; 10
(absolute-value  10) ; =&gt; 10
</code></pre>
    <br/>
    <br/>


    <li><b>RETURN-FROM and BLOCK</b></li>
    <br/>
    <ul>
        <li><b>RETURN-FROM</b> is not limited to functions — it exits from a <u>block</u> of code.</li>
        <li>A <code>BLOCK</code> is a named region introduced by the <code>BLOCK</code> special operator.</li>
        <li>Form: <code>(block name body...)</code></li>
    </ul>
<pre><code class="language-lisp line-numbers">(block my-block
  (format t "Before~%")
  (return-from my-block 42)
  (format t "After~%")) ; never executed
;; =&gt; 42
</code></pre>
    <br/>
    <ul>
        <li>When <code>RETURN-FROM</code> is executed, control jumps out of the block named <code>my-block</code>, returning the specified value.</li>
    </ul>
    <br/>
    <br/>


    <li><b>How DEFUN uses BLOCK</b></li>
    <br/>
    <ul>
        <li>Every function defined by <code>DEFUN</code> is automatically wrapped in a <b>BLOCK</b> whose name is the same as the function’s name.</li>
        <li>That means you can use <code>RETURN-FROM</code> with the function's name to exit immediately and specify a return value.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun first-positive (xs)
  (dolist (x xs)
    (when (plusp x)
      (return-from first-positive x)))
  nil)

(first-positive '(-3 -2 0 4 -1))
;; =&gt; 4
</code></pre>
    <br/>
    <ul>
        <li>Here, the function stops as soon as a positive number is found, and returns it right away.</li>
        <li>If no positive number exists, the loop ends and the final expression <code>nil</code> is returned.</li>
    </ul>
    <br/>
    <br/>


    <li><b>The RETURN shorthand</b></li>
    <br/>
    <ul>
        <li><b>RETURN</b> is a shorthand that exits the <b>nearest implicit block</b>.</li>
        <li>Many iteration constructs like <code>DOLIST</code> and <code>DO</code> automatically create such a block.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(dolist (x '(3 2 1 0 -1))
  (when (zerop x)
    (return 'done))
  (format t "x=~A~%" x))
;; Prints:
;; x=3
;; x=2
;; x=1
;; =&gt; DONE
</code></pre>
    <br/>
    <ul>
        <li>In this case, <code>RETURN</code> acts as <code>(return-from &lt;implicit-block&gt; 'done)</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>RETURN-FROM vs RETURN</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Form</th>
                <th>Returns from</th>
                <th>Typical use</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>(return-from name value)</code></td>
                <td>Explicitly named block (or function body)</td>
                <td>Used in <code>defun</code> or custom <code>block</code></td>
            </tr>
            <tr>
                <td><code>(return value)</code></td>
                <td>Nearest implicit block (like <code>dolist</code>, <code>do</code>, etc.)</td>
                <td>Quick exit inside iteration</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Early exits in complex logic</b></li>
    <br/>
    <ul>
        <li><code>RETURN-FROM</code> is useful for exiting multiple nested forms early without deep <code>IF</code> chains.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun safe-divide (a b)
  (if (zerop b)
      (return-from safe-divide :divide-by-zero)
      (/ a b)))

(safe-divide 10 2) ; =&gt; 5
(safe-divide 10 0) ; =&gt; :DIVIDE-BY-ZERO
</code></pre>
    <br/>
    <br/>


    <li><b>Multiple values and RETURN-FROM</b></li>
    <br/>
    <ul>
        <li><code>RETURN-FROM</code> can also return multiple values using <code>VALUES</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun divide-with-remainder (a b)
  (if (zerop b)
      (return-from divide-with-remainder (values nil nil))
      (return-from divide-with-remainder (values (floor (/ a b)) (mod a b)))))

(multiple-value-bind (q r) (divide-with-remainder 10 3)
  (list q r))
;; =&gt; (3 1)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Functions as Data (Higher-Order Functions)</h3>
<ol>
    <li><b>Functions are first-class values</b></li>
    <br/>
    <ul>
        <li>In Common Lisp, functions are <b>first-class objects</b>: you can store them in variables, pass them as arguments, and return them from other functions.</li>
        <br/>
        <li>To refer to a function object, use the <code>FUNCTION</code> special operator, or its shorthand <code>#'</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun foo (x) (* 2 x))

(function foo)
;; =&gt; #&lt;FUNCTION FOO&gt;

#'foo
;; =&gt; #&lt;FUNCTION FOO&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>#'</code> is to <code>FUNCTION</code> what <code>'</code> is to <code>QUOTE</code> — shorthand notation.</li>
        <br/>
        <li><code>'foo</code> &nbsp; → the symbol <code>FOO</code><br/>
            <code>#'foo</code> → the <u>function object</u> bound to <code>FOO</code></li>
    </ul>
    <br/>
    <br/>
    <br/>


    <li><b>Calling functions dynamically: FUNCALL</b></li>
    <br/>
    <ul>
        <li><code>FUNCALL</code> invokes a <u>function object</u> with a fixed number of arguments.</li>
        <li><code>(funcall #'foo 1 2 3)</code> is the same as <code>(foo 1 2 3)</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun add3 (a b c)
  (+ a b c))

(funcall #'add3 1 2 3)
;; =&gt; 6
</code></pre>
    <br/>
    <ul>
        <li><code>FUNCALL</code> is useful when you receive a function as an argument.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun apply-twice (fn x)
  (funcall fn (funcall fn x)))

(apply-twice #'1+ 10)
;; =&gt; 12
</code></pre>
    <br/>
    <br/>


    <li><b>Variable-function application: APPLY</b></li>
    <br/>
    <ul>
        <li><code>APPLY</code> is similar to <code>FUNCALL</code> but expects its final argument to be a <b>list of remaining arguments</b>.</li>
        <li>This allows calling a function when the number of arguments is not known in advance.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(apply #'+ 1 2 '(3 4 5))
;; Equivalent to: (+ 1 2 3 4 5)
;; =&gt; 15

(apply #'max '(1 9 3 5 7))
;; =&gt; 9
</code></pre>
    <br/>
    <ul>
        <li>In short:
            <ul>
                <li><b>FUNCALL</b> → use when you know the arguments at write time.</li>
                <li><b>APPLY</b> → use when arguments are already in a list.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Example: ASCII plotter using FUNCALL</b></li>
    <br/>
    <ul>
        <li>This function takes another function as an argument and prints an ASCII bar chart of its values.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun plot (fn min max step)
  (loop for i from min to max by step do
    (loop repeat (funcall fn i) do (format t "*"))
    (format t "~%")))

(plot #'exp 0 4 0.5)
*
*
**
****
*******
************
********************
*********************************
******************************************************
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>fn</code> can be any function — built-in, user-defined, or anonymous.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Combining lists with REDUCE</b></li>
    <br/>
    <ul>
        <li><code>REDUCE</code> applies a function cumulatively to elements of a sequence to "fold" it into one result.</li>
        <li>Form: <code>(reduce &lt;fn&gt; &lt;sequence&gt; &amp;key :initial-value &lt;init&gt; [:from-end t])</code></li>
    </ul>
<pre><code class="language-lisp line-numbers">(reduce #'+ '(1 2 3 4) :initial-value 0)
;; =&gt; (+ (+ (+ (+ 0 1) 2) 3) 4)
;; =&gt; 10

(reduce #'max '(1 4 2 9 3))
;; =&gt; 9
</code></pre>
    <br/>
    <ul>
        <li><code>REDUCE</code> is the foundation for many data aggregation operations.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Anonymous functions with LAMBDA</b></li>
    <br/>
    <ul>
        <li>You can create a function without giving it a name using <code>LAMBDA</code>.</li>
        <li>It produces a <u>function object</u> that you can pass, store, or call.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(funcall #'(lambda (x y) (+ x y)) 3 4)
;; =&gt; 7

(apply #'(lambda (&amp;rest xs) (reduce #'+ xs)) '(1 2 3 4))
;; =&gt; 10
</code></pre>
    <br/>
    <ul>
        <li><code>LAMBDA</code> forms are often used inline with <code>mapcar</code> and other higher-order functions:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(mapcar #'(lambda (x) (* x x)) '(1 2 3 4))
;; =&gt; (1 4 9 16)
</code></pre>
    <br/>
    <br/>


    <li><b>Closures: functions that capture variables</b></li>
    <br/>
    <ul>
        <li>If a <code>LAMBDA</code> refers to variables from its surrounding scope, it "remembers" them even after that scope ends — this is called a <b>closure</b>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun make-counter (&amp;optional (start 0))
  (let ((n start))
    #'(lambda ()
        (incf n))))

(let ((next (make-counter 10)))
  (list (funcall next)
        (funcall next)
        (funcall next)))
;; =&gt; (11 12 13)
</code></pre>
    <br/>
    <ul>
        <li>The inner function retains access to <code>n</code>, even after <code>make-counter</code> has finished executing.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Functions as arguments and return values</b></li>
    <br/>
    <ul>
        <li>You can freely pass functions as data or return them, enabling higher-order abstractions.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun make-adder (n)
  #'(lambda (x) (+ x n)))

(setq add5 (make-adder 5))
(funcall add5 10)
;; =&gt; 15
</code></pre>
    <br/>
    <ul>
        <li>This pattern is common in functional programming — you can build specialized functions dynamically.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Mapping functions over lists</b></li>
    <br/>
    <ul>
        <li>Common Lisp provides functions that take another function as a parameter and apply it to each element of a collection:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(mapcar #'1+ '(1 2 3 4))                    ; =&gt; (2 3 4 5)
(mapcar #'(lambda (x) (* x 10)) '(1 2 3))   ; =&gt; (10 20 30)
(mapcar #'+ '(1 2 3) '(10 20 30))           ; =&gt; (11 22 33)
</code></pre>
    <br/>
    <ul>
        <li><code>mapcar</code>, <code>mapcan</code>, and <code>map</code> are higher-order functions — they use other functions to perform their operations.</li>
    </ul>
    <br/>
    <br/>


    <li><mark>Summary</mark></li>
    <ul>
        <br/>
        <li>Functions in Lisp are <b>objects</b> — you can store, pass, and return them.</li>
        <br/>
        <li><code>#'name</code> retrieves a function object; <code>'name</code> refers to a symbol.</li>
        <br/>
        <li><code>FUNCALL</code> → call a function with known arguments.</li>
        <br/>
        <li><code>APPLY</code> → call a function with a list of arguments.</li>
        <br/>
        <li><code>REDUCE</code> → combine list elements using a function.</li>
        <br/>
        <li><code>LAMBDA</code> → create anonymous functions; closures can capture variables.</li>
        <br/>
        <li><code>MAPCAR</code> and friends → apply functions elementwise to collections.</li>
        <br/>
        <li>Treating functions as data enables higher-order programming — passing logic, not just numbers.</li>
        <br/>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>The difference between (3 4 5) and '(3 4 5)</h3>
<ol>
    <li><code>(3 4 5)</code> is a function call.<br/><br/>
        In Lisp, anything inside parentheses is treated as a function call unless you explicitly prevent evaluation.</li>
    <br/>
    <br/>
    <br/>
    <li><code>'(3 4 5)</code> is a quoted list — a literal value.<br/><br/>
        The single quote ( <code>'</code> ) is shorthand for </code>(quote ...)</code>.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>'(a b c) VS (list a b c)</h3>
<ol>
    <li>They are NOT the same thing!</li>
    <br/>
    <br/>
    <li><code>'(...)</code> is a quoted list (no evaluation).</li>
    <br/>
    <br/>
    <li><code>(list a b c)</code> calls the function list, after evaluating of each argument.</li>
    <br/>
    <br/>
    <li>Comparison with a real-life example:</li>
<pre><code class="language-lisp line-numbers">(setq a 10 b 20 c 30)
(list a b c)            ;; (10 20 30)
'(a b c)                ;; (A B C)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>PROGN</h3>
<ol>
    <li><b>PROGN</b> is a special operator in Common Lisp that evaluates multiple expressions in sequence and returns the value of the last one.</li>
    <br/>
    <br/>
    <li>Syntax: <code>(progn &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprN&gt;)</code></li>
    <br/>
    <br/>
    <li>Example:</li>
<pre><code class="language-lisp line-numbers">(progn
  (format t "Step 1~%")
  (format t "Step 2~%")
  (+ 2 3))   ;; last expression

;; Output:
;; Step 1
;; Step 2
;; 5
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>WHEN</h3>
<ol>
    <li><b>WHEN</b> is like a simplified IF that only has a then branch (no else).<br/>
        If the condition is true, it executes one or more expressions.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(let ((x 5))
  (when (&gt; x 0)
    (format t "x is positive~%")
    (* x 2)))
;; prints "x is positive"
;; returns 10
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>UNLESS</h3>
<ol>
    <li><b>UNLESS</b> is the logical opposite of <b>WHEN</b>. If the condition is false (<code>NIL</code>), it executes the body.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(let ((x 0))
  (unless (&gt; x 0)
    (format t "x is not positive~%")
    "Did something"))
;; prints "x is not positive"
;; returns "Did something"
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>AND, OR, and NOT</h3>
<ol>
    <li><b>AND</b> evaluates the arguments from left to right. <code>(and &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprN&gt;)</code><br/>
        It returns:</li>
    <ul>
        <br/>
        <li>The first falsy (<code>NIL</code>) value it encounters.</li>
        <br/>
        <li>Or the last value if all are true.</li>
    </ul>
    <br/>
    <br/>
    <li><b>OR</b> evaluates the arguments from left to right. <code>(or &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprN&gt;)</code><br/>
        It returns:</li>
    <ul>
        <br/>
        <li>The first non-falsy (non-<code>NIL</code>) value it encounters.</li>
        <br/>
        <li>Or <code>NIL</code> if all are false.</li>

    </ul>
    <br/>
    <br/>
    <li><b>NOT</b> returns <code>T</code> if the argument is <code>NIL</code>, and <code>NIL</code> otherwise.</li>
    <br/>
    <br/>
    <li>Examples:</li>
<pre><code class="language-lisp line-numbers">(and t 42 "hello")      ;; "hello"
(and t nil "oops")      ;; NIL
(and)                   ;; T

(or nil 0 "yes")        ;; 0
(or nil nil nil)        ;; NIL
(or)                    ;; NIL

(not nil)               ;; T
(not t)                 ;; NIL
(not 42)                ;; NIL (42 is truthy)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>DOLIST and DOTIMES</h3>
<ol>
    <li><b>DOLIST</b> iterates over each element in a list, binding it to a variable for each iteration.<br/>
        Syntax: <code>(dolist (&lt;variable&gt; &lt;list&gt; &amp;optional &lt;return-value&gt;) &lt;body&gt;)</code></li>
    <ul>
        <br/>
        <li><i>variable</i>: The loop variable that it takes on each element of <i>list</i>.</li>
        <br/>
        <li><i>list</i>: The list to iterate over.</li>
        <br/>
        <li><i>body</i>: Evaluation for each iteration.</li>
        <br/>
        <li><i>return-value</i>: Expression evaluated and returned after the loop finishes.</li>
    </ul>
    <br/>
<pre><code class="language-lisp line-numbers">(dolist (x '(a b c))
  (format t "Element: ~A~%" x))
;; Element: A
;; Element: B
;; Element: C


(dolist (x '(1 2 3) "Done")
  (print x))
;; Returns "Done" after printing the numbers.
</code></pre>
    <br/>
    <br/>
    <li><b>DOTIMES</b> iterates over a fixed number of times.<br/>
        Syntax: <code>(dotimes (&lt;variable&gt; &lt;N&gt; &amp;optional &lt;return-value&gt;) &lt;body&gt;)</code></li>
    <br/>
    <ul>
        <li>The loop counter starts at <i>0</i> and ends at <i>N-1</i>, exactly <i>N</i> iterations.</li>
        <br/>
    </ul>
<pre><code class="language-lisp line-numbers">(dotimes (i 5)
  (format t "i = ~A~%" i))
;; i = 0
;; i = 1
;; i = 2
;; i = 3
;; i = 4


(dotimes (i 3 "Loop done")
  (print i))
;; i = 0
;; i = 1
;; i = 2
;; "Loop done"
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>DO</h3>
<ol>
    <li><b>DO</b> is a low-level, general-purpose looping construct in Common Lisp.</li>
    <br/>
    <br/>
    <li>Syntax:</li>
<pre><code class="language-lisp line-numbers">(do ((&lt;var1&gt; &lt;init1&gt; [&lt;step1&gt;])
     (&lt;var2&gt; &lt;init2&gt; [&lt;step2&gt;])
     ...
     (&lt;varN&gt; &lt;initN&gt; [&lt;stepN&gt;]))
    (&lt;end-test&gt; [&lt;result-form&gt;])
  &lt;body&gt;)
</code></pre>
<ul>
    <br/>
    <li><i>var</i>: iter variable.</li>
    <br/>
    <li><i>init</i>: initial value (evaluated once at start).</li>
    <br/>
    <li><i>step</i>: optional. Controls how to update the variable (evaluated after each iteration).</li>
    <br/>
    <li><i>end-test</i>: checked before each iteration.<br/>
        If true, loop exists and evaluates <i>return-from</i>;<br/>
        if false, executes the loop body.</li>
    <br/>
    <li><i>return-from</i>: optional. If omitted, the loop returns <code>NIL</code>.</li>
</ul>
    <br/>
    <br/>
    <li>Basic Example:</li>
<pre><code class="language-lisp line-numbers">(do ((i 0 (+ i 1)))
    ((&gt;= i 5) 'done)
  (format t "i = ~A~%" i))

;; i = 0
;; i = 1
;; i = 2
;; i = 3
;; i = 4
;; DONE



(do ((i 0 (+ i 1))
     (j 10 (- j 2)))
    ((&gt; i 3) (list i j))
  (format t "i=~A, j=~A~%" i j))

;; i=0, j=10
;; i=1, j=8
;; i=2, j=6
;; i=3, j=4
;; (4 2)



(do ((x 5))         ; x stays 5 forever — infinite loop!
    ((<= x 0))
  (print x))
</code></pre>
    <br/>
    <br/>
    <li>Early exit using <b>RETURN</b>:</li>
<pre><code class="language-lisp line-numbers">(do ((i 0 (+ i 1)))
    (nil)           ; end test is NIL, infinite loop unless broken
  (when (= i 3) (return 'early))
  (print i))

;; 0
;; 1
;; 2
;; EARLY
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>LOOP</h3>
<ol>
    <li><b>LOOP</b> is a <u>macro</u> in Common Lisp that provides a declarative, English-like syntax for performing iterations and collecting results.</li>
    <br/>
    <br/>
    <li>Basic syntax: <code>(loop [&lt;loop-clauses&gt;])</code></li>
    <br/>
    <br/>
    <li>A loop is composed of clauses like:</li>
    <ul>
        <br/>
        <li>Iteration: <code>for</code>, <code>from</code>, <code>to</code>, <code>downto</code>, <code>below</code>, <code>above</code>, <code>by</code></li>
        <br/>
        <li>List / Vectors: <code>in</code>, <code>on</code>, <code>across</code></li>
        <br/>
        <li>Conditions: <code>when</code>, <code>unless</code>, <code>if</code>, <code>else</code>, <code>end</code></li>
        <br/>
        <li>Accumulators: <code>collect</code>, <code>append</code>, <code>sum</code>, <code>count</code>, <code>maximize</code>, <code>minimize</code></li>
        <br/>
        <li>Size effects: <code>do</code>, <code>finally</code>, <code>return</code></li>
        <br/>
        <li>Control: <code>while</code>, <code>until</code>, <code>repeat</code>, <code>named</code>, <code>initially</code></li>
    </ul>
    <br/>
    <br/>
    <li><mark>NOTE</mark>: <b>LOOP</b> syntax is non-Lispy — it doesn't follow S-expression style.</li>
    <br/>
    <br/>
    <li>Examples:</li>
    <br/>
<pre><code class="language-lisp line-numbers">(loop for x in '(a b c ) do
  (print x))
;; A
;; B
;; C

(loop as i from 1 to 3 do (print i))
;; 1
;; 2
;; 3

(loop for i from 1 to 3 do (print i))           ;; 1 2 3
(loop for i from 3 downto 1 do (print i))       ;; 3 2 1
(loop for i from 1 upto 3 do (print i))         ;; 1 2 3
(loop for i from 1 below 4 do (print i))        ;; 1 2 3
(loop for i from 5 above 2 do (print i))        ;; 5 4 3
(loop for i from 0 to 10 by 2 do (print i))     ;; 0 2 4 6 8 10

(loop repeat 3 do
  (print "Hello"))
;; "Hello"
;; "Hello"
;; "Hello"

(loop named my-loop
  for i from 1 to 10 do
    (when (= i 5) (return-from my-loop 'stopped)))
;; 'STOPPED

(loop
  initially (format t "Start~%")
  for i from 1 to 2 do (print i))

(loop
  for i from 1 to 2 do (print i)
  finally (format t "Done~%"))

(loop for x in '(a b c) collect x)                  ;; (A B C)
(loop for tail on '(1 2 3) collect tail)            ;; ((1 2 3) (2 3) (3))
(loop for x across #(10 20 30) collect (* x 2))     ;; (20 40 60)

(loop
  for i from 1 to 3
    if (evenp i)
      collect i
    else
      collect (- i)
    end)
;; (-1 2 -3)

(loop for i from 1 to 3 collect (* i i))            ;; (1 4 9)
(loop for x in '((a b) (c) (d e)) append x)         ;; (A B C D E)
(loop for i from 1 to 5 sum i)                      ;; 15
(loop for i in '(1 2 3 4 5) count (evenp i))        ;; 2
(loop for x in '(3 7 2 9 5) maximize x)             ;; 9
(loop for x in '(3 7 2 9 5) minimize x)             ;; 2
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Quote vs. Backquote</h3>
<ol>
    <li>Quote (<code>'</code> or <code>(quote ...)</code>): Don't evaluate, take it as data (prevents the usual evaluation of lists/symbols.).</li>
    <br/>
<pre><code class="language-lisp line-numbers">'foo            ;; FOO            ; a symbol, not the value of variable FOO
(quote foo)     ;; same as above

'(1 2 3)        ;; (1 2 3)        ; a literal list (don't evaluate it)
'(+ 1 2)        ;; (+ 1 2)        ; code-as-data, not 3
</code></pre>
    <br/>
    <li>Backquote / Quasiquote (<code>`</code> or <code>(quasiquote ...)</code>): Make a template, selectively evaluate with commas.</li>
    <ul>
        <br/>
        <li><code>,expr</code> (unquote): evaluates expr and inserts the result.</li>
        <br/>
        <li><code>,@expr</code> (unquote-splicing): evaluates expr and splices its elements into the surrounding list.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(let ((a 10) (b '(x y)))
  `(+ ,a 20)                ;; (+ 10 20)    NOTE: it evals a template to a list (not 30 that no further evaluation by far!).
  `(1 2 ,a ,@b 99))         ;; (1 2 10 X Y 99)

(let ((xs '(a b)))
  `(x ,xs y))   ;;  (X (A B) Y)
  `(x ,@xs y))  ;;  (X A B Y)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Destructing Parameter in DEFMACRO</h3>
<ol>
    <li>When you define a macro, you tell Lisp how to map the call form into symbols that you can use inside the macro body.</li>
<pre><code class="language-lisp line-numbers">(defmacro simple (x y)
  `(list ,x ,y))

(simple 10 20)
;; expands to (LIST 10 20) and will be evaluated when using it.
</code></pre>
    <br/>
    <br/>
    <li>In a <b>DEFMACRO</b>,
        your lambda list doesn't just bind symbols to arguments — it can pattern-match the entire shape of the call form.</li>
<pre><code class="language-lisp line-numbers">(defmacro swap! ((a b))
  `(let ((temp ,a))
     (setf ,a ,b
           ,b temp)))

(swap! (x y))
;; expands to:
;; (LET ((TEMP X)) (SETF X Y Y TEMP))



(defmacro let1 ((var val) &amp;body body)
  `(let ((,var ,val))
     ,@body))

(let1 (x (+ 1 2))
  (print x))
;; expands to (LET ((X (+ 1 2))) (PRINT X))



(defmacro bind2 ((a &amp;optional (b 10)) &amp;body body)
  `(let ((,a ,b))
     ,@body))

(bind2 (x 5) (print x)) ;; (LET ((X 5)) (PRINT X))
(bind2 (x) (print x))   ;; (LET ((X 10)) (PRINT X))



(defmacro with-options ((&amp;key (a 1) (b 2)) &amp;body body)
  `(let ((x ,a) (y ,b))
     ,@body))

(with-options (:a 10)
  (print (+ x y)))
;; expands to:
;; (LET ((X 10) (Y 2)) (PRINT (+ X Y)))
</code></pre>
    <br/>
    <br/>
    <li>All in all, what I understood it, in the language I could understand, is that:<br/>
        normally because <code>&amp;body</code> acts like <code>&amp;rest</code>,
        so this caused the <i>body</i> would very frequently also include the leter key parameters if given,<br/>
        using this pattern-matching, we can promote the key parameters before the body,
        so it very much eases our work to remove the key parameters from the macro call.
    </li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Collections</h3>
<ol>
    <li>Vectors are Common Lisp's basic integer-indexed collection, and they come in two flavors: fixed-size vectors and resizable vectors.</li>
    <br/>
    <br/>
    <li>Simplest way to construct a fixed-size vector with existing elements,
        is to use either <code>(vector [&lt;elements&gt;])</code> or <code>#(&lt;elements&gt;)</code> syntax:</li>
<pre><code class="language-lisp line-numbers">(vector)
#()

(vector 1)
#(1)

(vector 1 2)
#(1 2)
</code></pre>
    <br/>
    <br/>
    <li><b>MAKE-ARRAY</b> is much more vesatile;</li>
<pre><code class="language-lisp line-numbers">(make-array 5 :initial-element nil);    #(NIL NIL NIL NIL NIL)



;; `fill-pointer` stores the number of elements inside the vector.
(make-array 5 :fill-pointer 0);         #()



(defparameter *x* (make-array 5 :fill-pointer 0))

(vector-push 'a *x*);                   0
*x*                 ;					#(A)
(vector-push 'b *x*);					1
*x*                 ;					#(A B)
(vector-push 'c *x*);					2
*x*                 ;					#(A B C)
(vector-pop *x*)    ;					C
*x*                 ;					#(A B)
(vector-pop *x*)    ;					B
*x*                 ;					#(A)
(vector-pop *x*)    ;					A
*x*                 ;					#()



;; To make an arbitrarily resizable vector, you need to pass MAKE-ARRAY another keyword argument: `:adjustable`.
(make-array 5 :fill-pointer 0 :adjustable t); #()



;; You can also specify that a vector only contains certain types of elements (if non-specified, then it could take different kinds of elements).
(make-array 5 :fill-pointer 0 :adjustable t :element-type 'character)
</code></pre>
    <br/>
    <br/>
    <li>Vector as sequence:</li>
<pre><code class="language-lisp line-numbers">(sbcl)    (defparameter *x* (vector 1 2 3))

(sbcl)    (length *x*); 3
(sbcl)    (elt *x* 0) ; 1
(sbcl)    (elt *x* 1) ; 2
(sbcl)    (elt *x* 2) ; 3
(sbcl)    (elt *x* 3) ; error

(sbcl)    (setf (elt *x* 0) 10)
(sbcl)    *x*; #(10 2 3)
</code></pre>
    <br/>
    <br/>
    <li>Basic Sequence Functions</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Required Arguments</th>
                <th>Returns</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>COUNT</b></td>
                <td>Item and sequence.</td>
                <td>Number of times item appear in sequence.</td>
            </tr>
            <tr>
                <td><b>FIND</b></td>
                <td>Item and sequence.</td>
                <td>Item or <b>NIL</b></td>
            </tr>
            <tr>
                <td><b>POSITION</b></td>
                <td>Item and sequence.</td>
                <td>Index into sequence or <b>NIL</b> (0-indexed).</td>
            </tr>
            <tr>
                <td><b>REMOVE</b></td>
                <td>Item and sequence.</td>
                <td>Sequence with instances of item removed.</td>
            </tr>
            <tr>
                <td><b>SUBSTITUTE</b></td>
                <td>New-Item, item, and sequence.</td>
                <td>Sequence with instances of item replaced.</td>
            </tr>
        </tbody>
    </table>
    <br/>
<pre><code class="language-lisp line-numbers">(count 1 #(1 2 1 2 3 1 2 3 4))        ;		3
(remove 1 #(1 2 1 2 3 1 2 3 4))       ;		#(2 2 3 2 3 4)
(remove 1 '(1 2 1 2 3 1 2 3 4))       ;		(2 2 3 2 3 4)
(remove #\a "foobarbaz")              ;		"foobrbz"
(substitute 10 1 #(1 2 1 2 3 1 2 3 4));		#(10 2 10 2 3 10 2 3 4)
(substitute 10 1 '(1 2 1 2 3 1 2 3 4));		(10 2 10 2 3 10 2 3 4)
(substitute #\x #\b "foobarbaz")      ;		"fooxarxaz"
(find 1 #(1 2 1 2 3 1 2 3 4))         ;		1
(find 10 #(1 2 1 2 3 1 2 3 4))        ;		NIL
(position 1 #(1 2 1 2 3 1 2 3 4))     ;		0

(count "foo" #("foo" "bar" "baz") :test #'string=)   ; 1
(find 'c #((a 10) (b 20) (c 30) (d 40)) :key #'first); (C 30)

(find 'a #((a 10) (b 20) (a 30) (b 40)) :key #'first)            ; (A 10)
(find 'a #((a 10) (b 20) (a 30) (b 40)) :key #'first :from-end t); (A 30)

(remove #\a "foobarbaz" :count 1)            ; "foobrbaz"
(remove #\a "foobarbaz" :count 1 :from-end t); "foobarbz"

(count-if #'evenp #(1 2 3 4 5))        ; 2

(count-if-not #'evenp #(1 2 3 4 5))    ; 3

(position-if #'digit-char-p "abcd0001"); 4

(remove-if-not #'(lambda (x) (char= (elt x 0) #\f))
  #("foo" "bar" "baz" "foom"))
;; #("foo" "foom")

(remove-duplicates #(1 2 1 2 3 1 2 3 4))    ; #(1 2 3 4)

(concatenate 'vector #(1 2 3) '(4 5 6))     ; #(1 2 3 4 5 6)
(concatenate 'list #(1 2 3) '(4 5 6))       ; (1 2 3 4 5 6)
(concatenate 'string "abc" '(#\d #\e #\f))  ; "abcdef"

(merge 'vector #(1 3 5) #(2 4 6) #'&lt;)    ; #(1 2 3 4 5 6)
(merge 'list #(1 3 5) #(2 4 6) #'&lt;)      ; (1 2 3 4 5 6)

(subseq "foobarbaz" 3)                      ; "barbaz"
(subseq "foobarbaz" 3 6)                    ; "bar"



(defparameter *x* (copy-seq "foobarbaz"))

(setf (subseq *x* 3 6) "xxx")  ; subsequence and new value are same length
*x*
;; "fooxxxbaz"

(setf (subseq *x* 3 6) "abcd") ; new value too long, extra character ignored.
*x*
;; "fooabcbaz"

(setf (subseq *x* 3 6) "xx")   ; new value too short, only two characters changed
*x*
;; "fooxxcbaz"



(every #'evenp #(1 2 3 4 5))   ; NIL
(some #'evenp #(1 2 3 4 5))    ; T
(notany #'evenp #(1 2 3 4 5))  ; NIL
(notevery #'evenp #(1 2 3 4 5)); T



(map 'vector #'* #(1 2 3 4 5) #(10 9 8 7 6)); #(10 18 24 28 30)
(reduce #'+ #(1 2 3 4 5 6 7 8 9 10)); 55
</code></pre>
    <br/>
    <br/>
    <li>Standard Sequence Function Keyword Arguments</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Argument</th>
                <th>Meaning</th>
                <th>Default</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>:test</code></td>
                <td>Two-argument function used to compare item (or value extracted by <code>:key</code> function) to element.</td>
                <td><b>EQL</b></td>
            </tr>
            <tr>
                <td><code>:key</code></td>
                <td>One-argument function to extract key value from actual sequence element.<br/>
                    <b>NIL</b> means use element as is.</td>
                <td><b>NIL</b></td>
            </tr>
            <tr>
                <td><code>:start</code></td>
                <td>Starting index (inclusive) of subsequence.</td>
                <td><b>0</b></td>
            </tr>
            <tr>
                <td><code>:end</code></td>
                <td>Ending index (exclusive) of subsequence.<br/>
                    <b>NIL</b> indicates end of sequence.</td>
                <td><b>NIL</b></td>
            </tr>
            <tr>
                <td><code>:from-end</code></td>
                <td>If true, the sequence will be traversed in reverse order, from end to start.</td>
                <td><b>NIL</b></td>
            </tr>
            <tr>
                <td><code>:count</code></td>
                <td>Number indicating the number of elements to remove or substitute or <b>NIL</b> to indicate all (<b>REMOVE</b> and <b>SUBSTITUTE</b> only).</td>
                <td><b>NIL</b></td>
            </tr>
        </tbody>
    </table>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>CONS</h3>
<ol>
    <li>A cons cell is the fundamental 2-slot building block of Lisp lists.</li>
    <ul>
        <br/>
        <li>Slot1: <b>CAR</b> (the "first" thing)</li>
        <br/>
        <li>Slot2: <b>CDR</b> (the "rest" / tail pointer)</li>
    </ul>
    <br/>
    <br/>
    <li><code>(cons a d)</code> allocates a new cons cell whose <b>CAR</b> is <code>a</code> and <b>CDR</b> is <code>d</code>.</li>
<pre><code class="language-lisp line-numbers">(cons 1 2)          ; (1 . 2)   ;; an *improper* (dotted) pair
(cons 1 '(2 3))     ; (1 2 3)   ;; a proper list
(cons 'a 'b)        ; (A . B)
(cons '(a b) '(c d)); ((A B) C D)
</code></pre>
    <br/>
    <br/>
    <li>Proper vs. improper lists:</li>
    <ul>
        <br>
        <li>Proper list: chain of cons cells ending in NIL.<br/><br/>
            <code>(1 2 3)</code> is shorthand for <code>(1 . (2 . (3 . NIL)))</code>.</li>
        <br>
        <li>Improper list: CDR ends with a non-NIL atom.<br/><br/>
            <code>(1 . 2)</code> or <code>(1 2 . 3)</code>.</li>
    </ul>
    <br/>
    <br/>
    <br/>
    <li>Basic access: <code>CAR</code> and <code>CDR</code></li>
<pre><code class="language-lisp line-numbers">(car '(10 20 30)) ; 10
(cdr '(10 20 30)) ; (20 30)
(first '(10 20))  ; 10      ; synonyms: FIRST = CAR, REST = CDR
(rest  '(10 20))  ; (20)

(cadr  '(a b c))  ; B   ; = (car (cdr ...))
(caddr '(a b c d)); C



(cons 0 '(1 2 3))       ; (0 1 2 3)   ; O(1) prepend
(list 1 2 3)            ; (1 2 3)     ; constructs a fresh proper list
(list* 1 2 3)           ; (1 2 . 3)   ; last arg becomes the final CDR (can make improper)
(append '(1 2) '(3 4))  ; (1 2 3 4)   ; copies all but last list; O(n) in first arg



(let ((x (list 1 2 3)))
  (setf (car x) 99)     ; x =&gt; (99 2 3)
  (setf (cdr x) '(7))   ; x =&gt; (99 7)
  x)
</code></pre>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>SET, SEQ and SETF</h3>
<ol>
    <li>Overview</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Operator</th>
                <th>Type</th>
                <th>Evaluates 1st arg?</th>
                <th>Assigns to</th>
                <th>Works for</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>SETQ</code></td>
                <td>Special operator</td>
                <td class="hl-red-fg">No</td>
                <td>Lexical or special variables</td>
                <td>Variables only</td>
                <td>Fastest</td>
            </tr>
            <tr>
                <td><code>SETF</code></td>
                <td>Macro</td>
                <td class="hl-green-fg">Partially (place-specific)</td>
                <td>Generalized places</td>
                <td>Variables, array slots, struct slots, hash entries, accessors, ...</td>
                <td>Most general</td>
            </tr>
            <tr>
                <td><code>SET</code></td>
                <td>Function</td>
                <td class="hl-green-fg">Yes</td>
                <td>Global / special value cell of a symbol</td>
                <td>Symbols only</td>
                <td>Dynamic only; NEVER lexical</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>
    <li><b>SETQ</b> does not evaluate the variable name, and works on lexical variables (from <code>let</code>) and special/global variables.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(let ((a 1))
  (setq a 2)   ; modifies lexical A
  a)
;; 2
</code></pre>
    <br/>
    <br/>
    <li><b>SETF</b> is designed to be the general assignment operator, and works on simple variables (like <code>setq</code>) and complex places.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(setf x 10)                     ; variable
(setf (car mylist) 3)           ; list cell
(setf (slot-value obj 'age) 25) ; CLOS slot
(setf (gethash 'a table) 9)     ; hash table key
(setf (aref arr 3) 22)          ; array
(setf my-struct-field 100)      ; accessor
</code></pre>
    <br/>
    <br/>
    <li><b>SET</b> evaluates its first argument and its result must be a symbol. It only modifies the symbol's global/special value, not lexicals.<br/><br/>
        Because it is a Function. Functions in Lisp evaluate all their arguments before the function is called.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(set 'a 100)
a
;; 100


(let ((a 1))
  (set 'a 200))     ; Sets GLOBAL A, not this lexical A
a                   ; global A =&gt; 200


(let ((x 10))
  (set x 20))       ; ERROR: X holds 10, not a symbol




;; Global A
(set 'a 100)        ; sets global A = 100

(setq a 'b)         ; a now holds the symbol B
(set a 100)         ; sets global B = 100

(setq a 42)         ; replace `setq` here with `setf` is also ok.
(set a 100)         ; ERROR: 42 is not a symbol

(let ((a 1))
  (set 'a 999)      ; sets global A, lexical a still 1
  a)                ; 1
</code></pre>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Arrays (like in C / JS / TS)</h3>
<ol>
    <li>In Common Lisp, an <b>array</b> is a fixed-size, indexable collection of elements.<br/>
        It is similar to:
        <ul>
            <li>C: <code>int a[10];</code></li>
            <li>JS / TS: <code>const arr = [1, 2, 3];</code> (but JS arrays are dynamically sized)</li>
        </ul>
        In Lisp, <b>vectors</b> are just <u>one-dimensional arrays</u>. Here we focus on the general array features.
    </li>
    <br/>
    <br/>

    <li><b>Creating 1D Arrays</b> with <code>MAKE-ARRAY</code>:</li>
<pre><code class="language-lisp line-numbers">;; A 1D array of length 5, elements are unspecified, in SBCL it is treated as 0.
(defparameter *a* (make-array 5))

;; A 1D array of length 5, all elements start as 0
;; (defparameter *b* (make-array '(5) :initial-element 0))
(defparameter *b* (make-array 5 :initial-element 0))

*a*  ; =&gt; #(&lt;UNSPECIFIED&gt; &lt;UNSPECIFIED&gt; &lt;UNSPECIFIED&gt; &lt;UNSPECIFIED&gt; &lt;UNSPECIFIED&gt;)
*b*  ; =&gt; #(0 0 0 0 0)
</code></pre>
    <br/>
    <br/>

    <li><b>Array literal syntax</b> for 1D arrays (vectors):</li>
<pre><code class="language-lisp line-numbers">#(1 2 3)      ; vector of 3 elements
#("foo" "bar") ; vector of strings
</code></pre>
    <br/>
    <br/>

    <li><b>Accessing and modifying elements</b> with <code>AREF</code>:</li>
<pre><code class="language-lisp line-numbers">(defparameter *nums* (make-array 4 :initial-element 0))
; *NUMS* =&gt; #(0 0 0 0)

(aref *nums* 0)     ; =&gt; 0
(setf (aref *nums* 0) 42)
(aref *nums* 0)     ; =&gt; 42

(aref *nums* 3)     ; last valid index (0-based)
; (aref *nums* 4)   ; ERROR: index out of bounds
</code></pre>
    <br/>
    <br/>

    <li><b>Comparing to C / JS / TS</b> (informally):</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Language</th>
                <th>Example</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>C</td>
                <td><code>int a[4]; a[0] = 42;</code></td>
                <td>Fixed-size, contiguous memory.</td>
            </tr>
            <tr>
                <td>JS / TS</td>
                <td><code>const arr = [0, 0, 0, 0]; arr[0] = 42;</code></td>
                <td>Resizable, dynamic, can push/pop.</td>
            </tr>
            <tr>
                <td>Common Lisp</td>
                <td><code>(defparameter *a* (make-array 4 :initial-element 0))<br/>(setf (aref *a* 0) 42)</code></td>
                <td>By default fixed-size. Can also make adjustable arrays.</td>
            </tr>
        </tbody>
    </table>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Multi-Dimensional Arrays</h3>
<ol>
    <li>Common Lisp arrays can have <b>multiple dimensions</b>, like <code>int a[3][4];</code> in C.</li>
    <br/>
    <br/>

    <li>Use a <b>list of dimensions</b> with <code>MAKE-ARRAY</code>:</li>
<pre><code class="language-lisp line-numbers">;; 2 rows, 3 columns, all zeros
(defparameter *matrix* (make-array '(2 3) :initial-element 0))

*matrix*
;; =&gt; #2A((0 0 0)
;;        (0 0 0))
</code></pre>
    <br/>
    <br/>

    <li>Access elements with <code>AREF</code> using one index per dimension.</li>
<pre><code class="language-lisp line-numbers">(setf (aref *matrix* 0 0) 10)
(setf (aref *matrix* 0 1) 20)
(setf (aref *matrix* 1 2) 30)

*matrix*
;; =&gt; #2A((10 20 0)
;;        (0  0 30))

(aref *matrix* 1 2)  ; =&gt; 30
</code></pre>
    <br/>
    <br/>

    <li>Literal syntax for multi-dimensional arrays uses <code>#nA</code>:</li>
<pre><code class="language-lisp line-numbers">#2A((1 2 3)
    (4 5 6))
;; 2x3 array

#3A(((1 2) (3 4))
    ((5 6) (7 8)))
;; 3D array example
</code></pre>
    <br/>
    <br/>

    <li>Inspecting dimensions:</li>
<pre><code class="language-lisp line-numbers">(array-dimensions *matrix*) ; =&gt; (2 3)
(array-dimension *matrix* 0) ; =&gt; 2   ; rows
(array-dimension *matrix* 1) ; =&gt; 3   ; columns
</code></pre>
    <br/>
    <br/>

    <li>Iterating over a 2D array (like a matrix):</li>
<pre><code class="language-lisp line-numbers">(defun print-matrix (m)
  (destructuring-bind (rows cols) (array-dimensions m)
    (dotimes (i rows)
      (dotimes (j cols)
        (format t "~3A " (aref m i j)))
      (format t "~%"))))

(print-matrix *matrix*)
;; 10 20  0
;;  0  0 30
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Element Types and Specialized Arrays</h3>
<ol>
    <li>By default, arrays can hold any type (element type is <code>T</code>).<br/>
        You can restrict the <b>element type</b> for efficiency (implementation-dependent optimizations).
    </li>
    <br/>
    <br/>

    <li><b>Character array</b> (like a mutable string buffer):</li>
<pre><code class="language-lisp line-numbers">(defparameter *chars*
  (make-array 5 :element-type 'character
                :initial-element #\?))

*chars* ; =&gt; #(#\? #\? #\? #\? #\?)

(setf (aref *chars* 0) #\H)
(setf (aref *chars* 1) #\i)

*chars* ; =&gt; #(#\H #\i #\? #\? #\?)
</code></pre>
    <br/>
    <br/>

    <li><b>Numeric array</b>, e.g. <code>fixnum</code>:</li>
<pre><code class="language-lisp line-numbers">(defparameter *ints*
  (make-array 4 :element-type 'fixnum
                :initial-element 0))

(setf (aref *ints* 0) 10)
(setf (aref *ints* 1) 20)
*ints* ; =&gt; #(10 20 0 0)
</code></pre>
    <br/>
    <br/>

    <li>Element type does not change the <u>API</u> (you still use <code>aref</code> and <code>setf</code>),<br/>
        but can allow the implementation to store data more compactly (for example, like a C <code>int[]</code> or <code>char[]</code>).
    </li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Adjustable Arrays and "Dynamic" Behavior</h3>
<ol>
    <li>JavaScript / TypeScript arrays are <b>dynamic</b>: you can always <code>push</code> / <code>pop</code> and change their length.<br/>
        Common Lisp arrays are normally <b>fixed-size</b>, more like C arrays.<br/>
        However, you can ask Lisp to make an array:
        <ul>
            <br/>
            <li><b>adjustable</b> → it can be <code>ADJUST-ARRAY</code>-ed to a new size.</li>
            <br/>
            <li>with a <b>fill pointer</b> → it has a <i>logical length</i> that can be smaller than the physical capacity.</li>
            <br/>
        </ul>
        This combination behaves very similarly to a <b>dynamic array</b> with capacity + current length.
    </li>
    <br/>
    <br/>
    <br/>

    <li><b>What is a fill pointer?</b></li>
    <br/>
    <ul>
        <li>An array created with <code>:fill-pointer</code> has:
            <ul>
                <br/>
                <li>a <b>physical size</b> (capacity) → how many slots are allocated in memory;</li>
                <br/>
                <li>a <b>fill pointer</b> → how many elements are considered "in use".</li>
                <br/>
            </ul>
        </li>
        <br/>
        <li><code>(length array)</code> on such an array returns the <b>fill pointer</b>, not the physical size.</li>
        <br/>
        <li>Printing the array also shows only the part up to the fill pointer.</li>
        <br/>
        <li>You can still read/write elements beyond the fill pointer with <code>aref</code>, but they are "hidden" until you move the fill pointer forward.</li>
        <br/>
    </ul>
    <br/>

<pre><code class="language-lisp line-numbers">;; Physical size = 5, but logical length (fill-pointer) = 0
(defparameter *buf* (make-array 5 :fill-pointer 0))

*buf*         ; =&gt; #()
(length *buf*); =&gt; 0

;; Underlying storage exists:
(setf (aref *buf* 0) 42)
(setf (aref *buf* 1) 99)

;; Still hidden because fill-pointer is 0
*buf*         ; =&gt; #()
(length *buf*); =&gt; 0

;; Move fill pointer to 2
(setf (fill-pointer *buf*) 2)
*buf*         ; =&gt; #(42 99)
(length *buf*); =&gt; 2
</code></pre>
    <br/>
    <br/>

    <li><b>Creating adjustable, fill-pointer arrays</b> (dynamic-style):</li>
<pre><code class="language-lisp line-numbers">;; Start with capacity 0, fill-pointer 0, adjustable
(defparameter *dyn*
  (make-array 0
              :element-type 't
              :adjustable t
              :fill-pointer 0))

*dyn*            ; =&gt; #()
(length *dyn*)   ; =&gt; 0
</code></pre>
    <br/>
    <br/>

    <li><b>vector-push</b> and <b>vector-push-extend</b>:</li>
    <br/>
    <ul>
        <li><code>vector-push</code>:
            <ul>
                <br/>
                <li>stores a new element at index = current fill pointer;</li>
                <br/>
                <li>increments the fill pointer by 1;</li>
                <br/>
                <li>returns the index or <code>NIL</code> if no space is left.</li>
                <br/>
            </ul>
        </li>
        <br/>
        <li><code>vector-push-extend</code>:
            <ul>
                <br/>
                <li>same idea, but if there is no capacity, it <b>automatically grows</b> the array (calls <code>ADJUST-ARRAY</code> under the hood);</li>
                <br/>
                <li>takes an optional step size: <code>(vector-push-extend value array &amp;optional extension)</code>.</li>
                <br/>
            </ul>
        </li>
    </ul>
    <br/>

<pre><code class="language-lisp line-numbers">(vector-push-extend 10 *dyn*)
(vector-push-extend 20 *dyn*)
(vector-push-extend 30 *dyn*)

*dyn*          ; =&gt; #(10 20 30)
(length *dyn*) ; =&gt; 3

;; You can also pop like from a stack:
(vector-pop *dyn*) ; =&gt; 30
*dyn*              ; =&gt; #(10 20)
(length *dyn*)     ; =&gt; 2
</code></pre>
    <br/>
    <br/>

    <li><b>ADJUST-ARRAY</b>: manually change dimensions</li>
    <br/>
    <ul>
        <li><code>ADJUST-ARRAY</code> tries to <b>resize an existing array in-place</b> (if it is adjustable).</li>
        <br/>
        <li>Syntax: <code>(adjust-array array new-dimensions &amp;key ...)</code></li>
        <br/>
        <li>If the array is not adjustable, the implementation may still copy into a new array.</li>
        <br/>
    </ul>
    <br/>

<pre><code class="language-lisp line-numbers">;; Grow to physical size 5.
;; Existing contents kept, new slots initialized with 0.
(setf *dyn* (adjust-array *dyn* 5 :initial-element 0))

*dyn*          ; =&gt; #(10 20 0 0 0)
(length *dyn*) ; =&gt; 2      ; fill-pointer still 2!

;; If you want logical length = 5:
(setf (fill-pointer *dyn*) 5)
*dyn*          ; =&gt; #(10 20 0 0 0)
(length *dyn*) ; =&gt; 5
</code></pre>
    <br/>
    <br/>

    <li><b>Summary: :fill-pointer and :adjustable</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Option</th>
                <th>Meaning</th>
                <th>Typical use</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>:fill-pointer n</code></td>
                <td>Array has a logical length <code>n</code>. <code>length</code> and printing use this.</td>
                <td>Buffers, stacks, dynamic sequences built on top of an array.</td>
            </tr>
            <tr>
                <td><code>:fill-pointer t</code></td>
                <td>Fill pointer is initially set to the full size (all elements "in use").</td>
                <td>Start full, then shrink/grow by changing fill pointer.</td>
            </tr>
            <tr>
                <td><code>:adjustable t</code></td>
                <td>Array can be resized with <code>ADJUST-ARRAY</code> (and by <code>vector-push-extend</code>).</td>
                <td>Dynamic arrays whose capacity grows over time.</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

    <li><b>Other useful MAKE-ARRAY keyword arguments</b> (overview)</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Keyword</th>
                <th>Example</th>
                <th>Effect</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>:element-type</code></td>
                <td><code>(make-array 10 :element-type 'fixnum)</code></td>
                <td>Restrict element type (numbers, characters, etc.) for possible speed/memory benefits.</td>
            </tr>
            <tr>
                <td><code>:initial-element</code></td>
                <td><code>(make-array 5 :initial-element 0)</code></td>
                <td>Fill all slots with this value.</td>
            </tr>
            <tr>
                <td><code>:initial-contents</code></td>
                <td><code>(make-array 3 :initial-contents '(10 20 30))</code></td>
                <td>Provide a list (or nested lists for multi-d arrays) to initialize elements.</td>
            </tr>
            <tr>
                <td><code>:fill-pointer</code></td>
                <td><code>(make-array 10 :fill-pointer 0)</code></td>
                <td>Enable fill pointer (logical length), required for <code>vector-push</code>, <code>vector-pop</code>.</td>
            </tr>
            <tr>
                <td><code>:adjustable</code></td>
                <td><code>(make-array 0 :adjustable t)</code></td>
                <td>Allow resizing via <code>ADJUST-ARRAY</code>, used by <code>vector-push-extend</code>.</td>
            </tr>
            <tr>
                <td><code>:displaced-to</code></td>
                <td><code>(make-array 5 :displaced-to other-array)</code></td>
                <td>Make an array that shares storage with another (view / slice).</td>
            </tr>
            <tr>
                <td><code>:displaced-index-offset</code></td>
                <td><code>(make-array 3 :displaced-to big :displaced-index-offset 2)</code></td>
                <td>Start the view at a non-zero offset into the underlying array.</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

    <li><mark>Big picture</mark>:</li>
    <ul>
        <br/>
        <li>Plain <code>MAKE-ARRAY</code> → fixed-size, C-like array.</li>
        <br/>
        <li><code>:fill-pointer</code> → adds a "logical length" on top of the physical buffer.</li>
        <br/>
        <li><code>:adjustable t</code> → lets you grow/shrink the buffer itself.</li>
        <br/>
        <li><code>vector-push</code>, <code>vector-push-extend</code>, <code>vector-pop</code>, <code>ADJUST-ARRAY</code> → tools to build dynamic, JS-like behavior.</li>
        <br/>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Array Element Types</h3>
<ol>
    <li>Every Common Lisp array has an <b>element type</b> — this tells Lisp what kinds of values may be stored in it.</li>
    <br/>
    <br/>
    <li>If you don’t specify one, the default is <code>T</code> (anything).<br/>
        That means the array can hold numbers, strings, symbols, lists, other arrays — anything at all.
    </li>
    <br/>
    <br/>

    <li>However, when you restrict the element type, Lisp can often use a more compact and efficient internal representation —
        similar to how C arrays of <code>int</code> or <code>float</code> are faster and smaller than generic pointer arrays.
    </li>
    <br/>
    <br/>

    <li>Common element types include:</li>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Element Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>T</code></td>
                <td>Can hold any Lisp object (default). Slowest and most general.</td>
                <td><code>(make-array 3 :element-type 't :initial-contents '(a b c))</code></td>
            </tr>
            <tr>
                <td><code>BIT</code></td>
                <td>Only <code>0</code> or <code>1</code> allowed. Stored as packed bits, like a C <code>bool[]</code>.</td>
                <td><code>(make-array 8 :element-type 'bit :initial-contents '(1 0 1 0 1 0 0 1))</code></td>
            </tr>
            <tr>
                <td><code>CHARACTER</code></td>
                <td>Holds characters (like a mutable string).</td>
                <td><code>(make-array 5 :element-type 'character :initial-element #\?)</code></td>
            </tr>
            <tr>
                <td><code>BASE-CHAR</code></td>
                <td>Subset of <code>CHARACTER</code> (typically ASCII). Useful for portable strings.</td>
                <td><code>(make-array 5 :element-type 'base-char)</code></td>
            </tr>
            <tr>
                <td><code>STRING-CHAR</code></td>
                <td>Usually equivalent to <code>CHARACTER</code>, but emphasizes use as text data.</td>
                <td><code>(make-array 5 :element-type 'string-char)</code></td>
            </tr>
            <tr>
                <td><code>FIXNUM</code></td>
                <td>Machine-native integers (fast). Range depends on platform, typically 29–61 bits.</td>
                <td><code>(make-array 4 :element-type 'fixnum :initial-element 0)</code></td>
            </tr>
            <tr>
                <td><code>INTEGER</code></td>
                <td>Can hold any integer (including big integers). May be slower than <code>fixnum</code>.</td>
                <td><code>(make-array 3 :element-type 'integer :initial-element 42)</code></td>
            </tr>
            <tr>
                <td><code>(UNSIGNED-BYTE 8)</code></td>
                <td>8-bit unsigned integer (0–255). Ideal for bytes or binary file data.</td>
                <td><code>(make-array 4 :element-type '(unsigned-byte 8) :initial-element 255)</code></td>
            </tr>
            <tr>
                <td><code>(SIGNED-BYTE 8)</code></td>
                <td>8-bit signed integer (−128–127).</td>
                <td><code>(make-array 4 :element-type '(signed-byte 8) :initial-element -5)</code></td>
            </tr>
            <tr>
                <td><code>(UNSIGNED-BYTE 16)</code></td>
                <td>16-bit unsigned integer (0–65535).</td>
                <td><code>(make-array 2 :element-type '(unsigned-byte 16) :initial-element 1024)</code></td>
            </tr>
            <tr>
                <td><code>FLOAT</code></td>
                <td>Generic floating-point (may default to single-float).</td>
                <td><code>(make-array 3 :element-type 'float :initial-element 1.0)</code></td>
            </tr>
            <tr>
                <td><code>SINGLE-FLOAT</code></td>
                <td>32-bit float (IEEE single precision).</td>
                <td><code>(make-array 3 :element-type 'single-float :initial-element 0.0)</code></td>
            </tr>
            <tr>
                <td><code>DOUBLE-FLOAT</code></td>
                <td>64-bit float (IEEE double precision).</td>
                <td><code>(make-array 2 :element-type 'double-float :initial-element 0.0d0)</code></td>
            </tr>
            <tr>
                <td><code>COMPLEX</code></td>
                <td>Holds complex numbers (e.g. <code>#C(1.0 2.0)</code>).</td>
                <td><code>(make-array 2 :element-type 'complex :initial-contents '(#C(1 2) #C(3 4)))</code></td>
            </tr>
            <tr>
                <td><code>STRING</code></td>
                <td>Shortcut type for one-dimensional array of <code>character</code>.</td>
                <td><code>(make-array 5 :element-type 'string-char)</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

    <li><b>Testing element type</b> of an array:</li>
<pre><code class="language-lisp line-numbers">(array-element-type #(1 2 3))
;; =&gt; T

(array-element-type (make-array 10 :element-type 'bit))
;; =&gt; BIT
</code></pre>
    <br/>
    <br/>

    <li><b>Typed arrays are specialized</b>:</li>
    <br/>
    <ul>
        <li>Each Lisp implementation may store specialized arrays (e.g., <code>(unsigned-byte 8)</code>) as compact byte vectors.</li>
        <br/>
        <li>This enables efficient binary I/O — e.g., reading/writing images, files, or raw buffers.</li>
        <br/>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *bytes*
  (make-array 4 :element-type '(unsigned-byte 8)
                :initial-contents '(72 101 108 108))) ; "Hell"

(write-sequence *bytes* #p"out.bin")
</code></pre>
    <br/>
    <br/>

    <li><b>Multi-dimensional typed arrays</b>:</li>
<pre><code class="language-lisp line-numbers">(make-array '(3 3)
             :element-type 'single-float
             :initial-element 0.0)
;; =&gt; #2A((0.0 0.0 0.0)
;;        (0.0 0.0 0.0)
;;        (0.0 0.0 0.0))
</code></pre>
    <br/>
    <br/>

    <li><mark>Notes and portability tips:</mark></li>
    <ul>
        <br/>
        <li>Not every implementation supports every numeric bit-width (e.g. 16-bit or 32-bit may be missing).</li>
        <br/>
        <li>Standard portable types:
            <ul>
                <li><code>bit</code></li>
                <li><code>character</code> / <code>base-char</code></li>
                <li><code>fixnum</code></li>
                <li><code>single-float</code>, <code>double-float</code></li>
                <li><code>t</code></li>
            </ul>
        </li>
        <br/>
        <li>Arrays of <code>bit</code> can be created using the specialized constructor <code>MAKE-BIT-VECTOR</code> (implementation-specific).</li>
        <br/>
        <li>Strings are just arrays of <code>character</code>, so functions like <code>AREF</code> and <code>ADJUST-ARRAY</code> work on them too.</li>
        <br/>
    </ul>
    <br/>

    <li><b>Example summary:</b></li>
<pre><code class="language-lisp line-numbers">(defparameter *arr-any*  (make-array 3 :element-type 't))
(defparameter *arr-int*  (make-array 3 :element-type 'fixnum :initial-element 42))
(defparameter *arr-float* (make-array 3 :element-type 'single-float :initial-element 0.5))
(defparameter *arr-bit*  (make-array 8 :element-type 'bit :initial-contents '(1 0 1 0 1 1 0 0)))
(defparameter *arr-char* (make-array 4 :element-type 'character :initial-contents "LISP"))

(list
  (array-element-type *arr-any*)
  (array-element-type *arr-int*)
  (array-element-type *arr-float*)
  (array-element-type *arr-bit*)
  (array-element-type *arr-char*))
;; =&gt; (T FIXNUM SINGLE-FLOAT BIT CHARACTER)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>CAR and CDR</h3>
<ol>
    <li><b>Historical meaning:</b><br/>
        The names <code>CAR</code> and <code>CDR</code> come from the 1950s IBM 704 machine architecture.
        <ul>
            <br/>
            <li><code>CAR</code> stood for "Contents of the Address Register"</li>
            <br/>
            <li><code>CDR</code> stood for "Contents of the Decrement Register"</li>
            <br/>
            <li>They referred to two parts of a memory word that held a pair of pointers.</li>
            <br/>
        </ul>
        Today, they simply mean:
        <ul>
            <li><code>CAR</code> → the <b>first element</b> of a list (the head).</li>
            <li><code>CDR</code> → the <b>rest of the list</b> (the tail).</li>
        </ul>
    </li>
    <br/>
    <br/>

    <li><b>Basic usage:</b></li>
<pre><code class="language-lisp line-numbers">(defparameter *nums* '(10 20 30 40))

(car *nums*) ; =&gt; 10
(cdr *nums*) ; =&gt; (20 30 40)
</code></pre>
    <br/>
    <br/>

    <li><b>CAR and CDR act on cons cells</b> (pairs):</li>
    <br/>
    <ul>
        <li>A list <code>'(10 20 30)</code> is really shorthand for a chain of <code>CONS</code> pairs:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(cons 10 (cons 20 (cons 30 nil)))
;; = (10 20 30)

(car '(10 20 30)) ; =&gt; 10
(cdr '(10 20 30)) ; =&gt; (20 30)
</code></pre>
    <br/>
    <br/>

    <li><b>Understanding the structure:</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Expression</th>
                <th>Diagram</th>
                <th>Result</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>'(10 20 30)</code></td>
                <td>
                    <code>[10 | o]→[20 | o]→[30 | NIL]</code>
                </td>
                <td>List of three numbers</td>
            </tr>
            <tr>
                <td><code>(car '(10 20 30))</code></td>
                <td>
                    Returns first cell’s left part
                </td>
                <td><code>10</code></td>
            </tr>
            <tr>
                <td><code>(cdr '(10 20 30))</code></td>
                <td>
                    Returns pointer to second cell
                </td>
                <td><code>(20 30)</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

    <li><b>Nested CAR/CDR combinations</b></li>
    <br/>
    <ul>
        <li>You can chain <code>CAR</code> and <code>CDR</code> to walk down nested lists.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *lst* '((a b) (c d) (e f)))

(car *lst*)        ; =&gt; (A B)
(cdr *lst*)        ; =&gt; ((C D) (E F))
(car (car *lst*))  ; =&gt; A
(car (cdr *lst*))  ; =&gt; (C D)
(car (cdr (car *lst*))) ; =&gt; B
</code></pre>
    <br/>
    <br/>

    <li><b>Shorthand forms:</b> Lisp has built-in combinations up to four levels deep:</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Form</th>
                <th>Equivalent to</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>(caar x)</code></td>
                <td><code>(car (car x))</code></td>
                <td>First of the first</td>
            </tr>
            <tr>
                <td><code>(cadr x)</code></td>
                <td><code>(car (cdr x))</code></td>
                <td>Second element</td>
            </tr>
            <tr>
                <td><code>(caddr x)</code></td>
                <td><code>(car (cdr (cdr x)))</code></td>
                <td>Third element</td>
            </tr>
            <tr>
                <td><code>(cddr x)</code></td>
                <td><code>(cdr (cdr x))</code></td>
                <td>All but the first two elements</td>
            </tr>
        </tbody>
    </table>
<pre><code class="language-lisp line-numbers">(defparameter *nums* '(1 2 3 4))
(cadr *nums*)  ; =&gt; 2
(caddr *nums*) ; =&gt; 3
(cddr *nums*)  ; =&gt; (3 4)
</code></pre>
    <br/>
    <br/>

    <li><b>Modern synonyms (more readable):</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Old</th>
                <th>Modern equivalent</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>car</code></td>
                <td><code>first</code></td>
                <td>Head of list</td>
            </tr>
            <tr>
                <td><code>cdr</code></td>
                <td><code>rest</code></td>
                <td>Tail of list</td>
            </tr>
            <tr>
                <td><code>(cadr x)</code></td>
                <td><code>(second x)</code></td>
                <td>Second element</td>
            </tr>
            <tr>
                <td><code>(caddr x)</code></td>
                <td><code>(third x)</code></td>
                <td>Third element</td>
            </tr>
            <tr>
                <td><code>(cdddr x)</code></td>
                <td><code>(nthcdr 3 x)</code></td>
                <td>Drop first 3 elements</td>
            </tr>
        </tbody>
    </table>
<pre><code class="language-lisp line-numbers">(first '(a b c d)) ; =&gt; A
(rest  '(a b c d)) ; =&gt; (B C D)
(third '(a b c d)) ; =&gt; C
(nth 2 '(a b c d)) ; =&gt; C
</code></pre>
    <br/>
    <br/>

    <li><mark>Summary</mark>:</li>
    <ul>
        <br/>
        <li><code>CAR</code> → first element of a cons/list.</li>
        <br/>
        <li><code>CDR</code> → rest of the list (tail).</li>
        <br/>
        <li>They work on <code>CONS</code> pairs: <code>(cons a b)</code> → <code>(car x)=a</code>, <code>(cdr x)=b</code>.</li>
        <br/>
        <li>Combined forms: <code>CADR</code>, <code>CADDR</code>, etc. for convenience.</li>
        <br/>
        <li>Modern names: <code>FIRST</code>, <code>REST</code>, <code>SECOND</code>, <code>THIRD</code>.</li>
        <br/>
        <li>CAR/CDR are to Lisp what pointer dereferencing is to C — they’re the fundamental way of walking linked structures.</li>
        <br/>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>CONS</h3>
<ol>
    <li>A <b>CONS</b> is the most fundamental data structure in Lisp.
        It constructs a pair of two values, traditionally called:
        <ul>
            <li><b>CAR</b> → the first value (left half)</li>
            <li><b>CDR</b> → the second value (right half)</li>
        </ul>
        Together, these form a <b>cons cell</b> — the atomic "node" of all lists in Lisp.
    </li>
    <br/>
    <br/>

    <li><b>Creating a pair:</b></li>
<pre><code class="language-lisp line-numbers">(cons 'apple 'banana)
;; =&gt; (APPLE . BANANA)
</code></pre>
    <br/>
    <ul>
        <li>This notation <code>(A . B)</code> means "a pair whose CAR is A and CDR is B".</li>
        <li>If the CDR is <code>NIL</code>, Lisp prints it as a normal list: <code>(A)</code>.</li>
    </ul>
    <br/>
    <br/>

    <li><b>CONS is how all lists are built</b> — a list is just a chain of cons cells where each CDR points to the next cons (and the last points to <code>NIL</code>):</li>
<pre><code class="language-lisp line-numbers">(cons 'a (cons 'b (cons 'c nil)))
;; =&gt; (A B C)

;; Equivalent literal
'(A B C)
</code></pre>
    <br/>
    <br/>

    <li><b>Understanding the structure visually:</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Code</th>
                <th>Cons Cell Chain</th>
                <th>Printed Form</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>(cons 'a 'b)</code></td>
                <td><code>[a | b]</code></td>
                <td><code>(A . B)</code></td>
            </tr>
            <tr>
                <td><code>(cons 'a (cons 'b nil))</code></td>
                <td><code>[a | o]→[b | NIL]</code></td>
                <td><code>(A B)</code></td>
            </tr>
            <tr>
                <td><code>(cons 'a (cons 'b (cons 'c nil)))</code></td>
                <td><code>[a | o]→[b | o]→[c | NIL]</code></td>
                <td><code>(A B C)</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>
    <br/>

    <li><b>Dotted pairs vs proper lists</b></li>
    <br/>
    <ul>
        <li>If the <code>CDR</code> of a cons is not another cons or <code>NIL</code>, Lisp prints it as a <b>dotted pair</b>:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(cons 'a 'b)          ; =&gt; (A . B)
(cons 'a '(b c d))    ; =&gt; (A B C D)
(cons '(a b) '(c d))  ; =&gt; ((A B) C D)
</code></pre>
    <br/>
    <ul>
        <li><b>Proper list</b> → ends with <code>NIL</code>.</li>
        <li><b>Improper list (dotted)</b> → ends with something else.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(cons 'a (cons 'b 'c))
;; =&gt; (A B . C)
</code></pre>
    <br/>
    <br/>
    <br/>

    <li><b>Accessing parts of a CONS cell:</b></li>
<pre><code class="language-lisp line-numbers">(defparameter *pair* (cons 'x 'y))

(car *pair*) ; =&gt; X
(cdr *pair*) ; =&gt; Y
</code></pre>
    <br/>
    <ul>
        <li>Each cell always holds exactly two parts — even in lists of many elements.</li>
    </ul>
    <br/>
    <br/>
    <br/>

    <li><b>CONSing lists together</b></li>
<pre><code class="language-lisp line-numbers">(cons 0 '(1 2 3))
;; =&gt; (0 1 2 3)

(cons '(1 2) '(3 4))
;; =&gt; ((1 2) 3 4)
</code></pre>
    <br/>
    <ul>
        <li><code>CONS</code> only adds a single element to the front; it doesn’t flatten lists.</li>
        <br/>
        <li>If you want to concatenate, use <code>APPEND</code> instead.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(append '(1 2) '(3 4))
;; =&gt; (1 2 3 4)
</code></pre>
    <br/>
    <br/>
    <br/>

    <li><b>Common idioms:</b></li>
<pre><code class="language-lisp line-numbers">(push &lt;item&gt; &lt;list&gt;)
;; same as (setf &lt;list&gt; (cons &lt;item&gt; &lt;list&gt;))

(pop &lt;list&gt;)
;; removes and returns the first element (like stack pop)
</code></pre>
    <br/>
    <ul>
        <li><code>PUSH</code> and <code>POP</code> are macros built around <code>CONS</code> and <code>CAR/CDR</code>.</li>
        <br/>
        <li>This makes linked-list stacks trivial to implement.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *stack* nil)
(push 'first *stack*) ; =&gt; (FIRST)
(push 'second *stack*) ; =&gt; (SECOND FIRST)
(pop *stack*)         ; =&gt; SECOND
*stack*               ; =&gt; (FIRST)
</code></pre>
    <br/>
    <br/>
    <br/>

    <li><b>Pairs as associations:</b></li>
<pre><code class="language-lisp line-numbers">(defparameter *pair* (cons 'key 'value))
*pair* ; =&gt; (KEY . VALUE)

(car *pair*) ; =&gt; KEY
(cdr *pair*) ; =&gt; VALUE
</code></pre>
    <br/>
    <ul>
        <li>Such pairs are used in <b>association lists</b> (<code>alist</code>), which map keys to values.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *alist*
  '((apple . red)
    (banana . yellow)
    (grape . purple)))

(assoc 'banana *alist*)
;; =&gt; (BANANA . YELLOW)

(cdr (assoc 'banana *alist*))
;; =&gt; YELLOW
</code></pre>
    <br/>
    <br/>
    <br/>

    <li><b>CONS memory analogy:</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>In Lisp</th>
                <th>In C analogy</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>(cons a b)</code></td>
                <td><code>struct Pair { void *car; void *cdr; }</code></td>
            </tr>
            <tr>
                <td><code>(car x)</code></td>
                <td><code>x-&gt;car</code></td>
            </tr>
            <tr>
                <td><code>(cdr x)</code></td>
                <td><code>x-&gt;cdr</code></td>
            </tr>
            <tr>
                <td><code>(cons 1 (cons 2 (cons 3 nil)))</code></td>
                <td>Linked list: head→next→next→NULL</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

    <li><b>Summary:</b></li>
    <ul>
        <br/>
        <li><code>CONS</code> creates a pair (two fields: <code>CAR</code> and <code>CDR</code>).</li>
        <br/>
        <li>Lists are chains of cons cells where each <code>CDR</code> points to the next.</li>
        <br/>
        <li><code>(A . B)</code> is a pair; <code>(A B C)</code> is shorthand for nested <code>CONS</code> ending with <code>NIL</code>.</li>
        <br/>
        <li><code>CAR</code> and <code>CDR</code> retrieve the left and right parts of a cons cell.</li>
        <br/>
        <li><code>PUSH</code> and <code>POP</code> macros are built upon <code>CONS</code>.</li>
        <br/>
        <li><b>Everything in Lisp lists</b> — trees, stacks, queues, association tables — is ultimately built from <code>CONS</code> cells.</li>
        <br/>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Using Symbols in Common Lisp</h3>
<ol>
    <li><b>What is a symbol really?</b></li>
    <br/>
    <ul>
        <li>A symbol is an object with (conceptually) 4 main slots:
            <ul>
                <br/>
                <li><b>NAME</b> — how it prints, e.g. <code>"FOO"</code></li>
                <br/>
                <li><b>VALUE</b> — used when the symbol is evaluated as a variable</li>
                <br/>
                <li><b>FUNCTION</b> — used when it is called as a function</li>
                <br/>
                <li><b>PLIST</b> — a property list attached to this symbol</li>
                <br/>
            </ul>
        </li>
        <li>Plus: each symbol belongs to a <b>package</b> (a namespace), like <code>COMMON-LISP</code> or <code>CL-USER</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Using symbols as variable names</b></li>
    <br/>
    <ul>
        <li>When you write <code>(setq x 10)</code> or <code>(let ((x 10)) ...)</code>,
            the symbol <code>X</code> is used as a variable name.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defvar *counter* 0)     ; *COUNTER* is a symbol used as a global variable
(setq *counter* 10)      ; store 10 in its value cell

(let ((x 42))            ; X is a symbol used as a local variable
  x)                     ; =&gt; 42
</code></pre>
    <br/>
    <ul>
        <li>Evaluating a symbol as an expression uses its <b>value cell</b>:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(setq a 100)
a                       ; =&gt; 100   ; evaluates to the value cell of A

(symbol-value 'a)       ; =&gt; 100   ; same, but using the symbol object explicitly
</code></pre>
    <br/>
    <br/>


    <li><b>Using symbols as function names</b></li>
    <br/>
    <ul>
        <li>When you define a function with <code>DEFUN</code>, the symbol’s <b>function cell</b> is filled.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun square (x)
  (* x x))

(square 5)                ; =&gt; 25
(function square)         ; =&gt; #&lt;FUNCTION SQUARE&gt;
(symbol-function 'square) ; same as FUNCTION but as a function
</code></pre>
    <br/>
    <ul>
        <li>Evaluating <code>(square 5)</code>:
            <ul>
                <br/>
                <li>First position: <code>square</code> is treated as a function name.</li>
                <br/>
                <li>Lisp looks up the <b>function cell</b> of the symbol <code>SQUARE</code>.</li>
                <br/>
                <li>Then calls it with argument <code>5</code>.</li>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>Symbols as data (quoted)</b></li>
    <br/>
    <ul>
        <li>If you write a symbol <b>quoted</b>, Lisp does not treat it as a variable or function — it is just data.</li>
    </ul>
<pre><code class="language-lisp line-numbers">'foo       ; symbol FOO
(quote foo); same

'(a b c)   ; list of three symbols: A, B, C
</code></pre>
    <br/>
    <ul>
        <li>This is the core of "code as data": Lisp programs are made of symbols and lists, and you can manipulate them directly.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *expr* '(+ 1 2))
*expr*           ; =&gt; (+ 1 2)  ; data (list of symbols and numbers)
(eval *expr*)    ; =&gt; 3        ; treat it as code and evaluate
</code></pre>
    <br/>
    <br/>


    <li><b>Symbols as keys in plists and alists</b></li>
    <br/>
    <ul>
        <li>Symbols are often used as <b>keys</b> because they are easy to read and efficiently comparable.</li>
    </ul>

    <p><u>Property lists (plists) using keywords</u>:</p>
<pre><code class="language-lisp line-numbers">(defparameter *person*
  '(:name "Abby"
    :age  20
    :city "Berlin"))

(getf *person* :name) ; =&gt; "Abby"
(getf *person* :age)  ; =&gt; 20
</code></pre>

    <p><u>Association lists (alists) using ordinary symbols</u>:</p>
<pre><code class="language-lisp line-numbers">(defparameter *colors*
  '((apple  . red)
    (banana . yellow)
    (grape  . purple)))

(assoc 'banana *colors*)        ; =&gt; (BANANA . YELLOW)
(cdr (assoc 'banana *colors*))  ; =&gt; YELLOW
</code></pre>
    <br/>
    <ul>
        <li>For configuration, keywords (like <code>:name</code>, <code>:age</code>) are very common.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Symbols and keyword parameters</b></li>
    <br/>
    <ul>
        <li>When you define a function with <code>&amp;key</code> parameters, you typically call it with <b>keyword symbols</b>:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun make-user (&amp;key name age admin)
  (list :name name :age age :admin admin))

(make-user :name "Alice" :age 30 :admin t)
;; =&gt; (:NAME "Alice" :AGE 30 :ADMIN T)
</code></pre>
    <br/>
    <ul>
        <li>Here <code>:name</code>, <code>:age</code>, and <code>:admin</code> are symbols from the <b>KEYWORD</b> package that evaluate to themselves.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Symbol properties: symbol-plist</b></li>
    <br/>
    <ul>
        <li>Every symbol has its own <b>property list</b> (plist) attached to it.</li>
        <li>You can store arbitrary metadata on a symbol.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(setf (symbol-plist 'user-id)
      '(:type integer :db-column "user_id"))

(symbol-plist 'user-id)
;; =&gt; (:TYPE INTEGER :DB-COLUMN "user_id")

(getf (symbol-plist 'user-id) :db-column)
;; =&gt; "user_id"
</code></pre>
    <br/>
    <ul>
        <li>This is like attaching annotations/attributes to identifiers.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Symbols and packages (namespaces)</b></li>
    <br/>
    <ul>
        <li>Each symbol lives in a <b>package</b>. A package is basically a namespace.</li>
        <li>When you see <code>cl:car</code>, it means "the symbol named CAR from the COMMON-LISP package".</li>
    </ul>
<pre><code class="language-lisp line-numbers">(symbol-name 'car)       ; =&gt; "CAR"
(symbol-package 'car)    ; =&gt; #&lt;PACKAGE "COMMON-LISP"&gt;

;; Intern a new symbol in a custom package:
(make-package "MY-APP")
(intern "FOO" "MY-APP")  ; =&gt; MY-APP::FOO
</code></pre>
    <br/>
    <ul>
        <li>Packages prevent name clashes between libraries (two libraries can both have a function called <code>START</code> in different packages).</li>
    </ul>
    <br/>
    <br/>


    <li><b>Changing how symbols behave: value vs function</b></li>
    <br/>
    <ul>
        <li>Because symbols have separate <b>value</b> and <b>function</b> cells, you can use the same name for both:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun foo (x) (+ x 1)) ; define function FOO
(setq foo 10)           ; define variable FOO

foo          ; =&gt; 10          ; value cell
(foo 5)      ; =&gt; 6           ; function cell

(symbol-value 'foo)     ; =&gt; 10
(symbol-function 'foo)  ; =&gt; #&lt;FUNCTION FOO&gt;
</code></pre>
    <br/>
    <ul>
        <li>This sometimes confuses beginners, but it’s powerful — code and data can use the same symbolic names with different roles.</li>
    </ul>
    <br/>
    <br/>


    <li><mark>Summary</mark></li>
    <ul>
        <br/>
        <li>Symbols are <b>names</b> that can be used as variables, function names, macro names, etc.</li>
        <br/>
        <li>Quoted symbols (like <code>'foo</code>) are <b>data</b>, not variables.</li>
        <br/>
        <li>Symbols are ideal <b>keys</b> for plists, alists, and keyword arguments.</li>
        <br/>
        <li>Each symbol has:
            <ul>
                <li>a <b>value cell</b> (variables),</li>
                <li>a <b>function cell</b> (functions/macros),</li>
                <li>a <b>property list</b> (metadata),</li>
                <li>a <b>package</b> (namespace).</li>
            </ul>
        </li>
        <br/>
        <li>Keywords like <code>:name</code> are symbols in the <b>KEYWORD</b> package and evaluate to themselves.</li>
        <br/>
        <li>When you think "symbol", think "a named slot object that can represent code, data, and metadata at the same time".</li>
        <br/>
    </ul>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Association Lists (Alists)</h3>
<ol>
    <li><b>What is an association list?</b></li>
    <br/>
    <ul>
        <li>An <b>association list</b> (short: <b>alist</b>) is a list of pairs, each made by <code>CONS</code> or written as <code>(key . value)</code>.</li>
        <br/>
        <li>It represents a simple mapping of <b>keys → values</b>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *colors*
  '((apple  . red)
    (banana . yellow)
    (grape  . purple)))

;; Each element is a cons cell:
;; (car pair) = key, (cdr pair) = value
</code></pre>
    <br/>
    <br/>

    <li><b>Accessing data with ASSOC</b></li>
    <br/>
    <ul>
        <li><code>ASSOC</code> searches the alist for a pair whose key matches the argument using <code>EQL</code> by default.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(assoc 'banana *colors*)
;; =&gt; (BANANA . YELLOW)

(cdr (assoc 'banana *colors*))
;; =&gt; YELLOW
</code></pre>
    <br/>
    <ul>
        <li>If no key matches, <code>ASSOC</code> returns <code>NIL</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(assoc 'pear *colors*) ; =&gt; NIL
</code></pre>
    <br/>
    <br/>

    <li><b>Custom comparison functions</b></li>
    <br/>
    <ul>
        <li>You can specify a test function via <code>:test</code> keyword (e.g. <code>equal</code>, <code>string=</code>, etc.).</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *people*
  '(("Alice" . 23)
    ("Bob"   . 30)
    ("Eve"   . 28)))

(assoc "Bob" *people* :test #'string=)
;; =&gt; ("Bob" . 30)
</code></pre>
    <br/>
    <br/>

    <li><b>Adding or updating entries</b></li>
    <br/>
    <ul>
        <li>You can prepend a new pair using <code>acons</code> ("add cons").</li>
        <li>It constructs <code>(cons (cons key value) alist)</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *grades* nil)

(setf *grades* (acons 'alice 95 *grades*))
(setf *grades* (acons 'bob   88 *grades*))

*grades* ; =&gt; ((BOB . 88) (ALICE . 95))
</code></pre>
    <br/>
    <ul>
        <li>Updating a key is easy — just use <code>assoc</code> and <code>rplacd</code> to change its value in place.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(let ((cell (assoc 'bob *grades*)))
  (when cell
    (rplacd cell 90)))

*grades* ; =&gt; ((BOB . 90) (ALICE . 95))
</code></pre>
    <br/>
    <ul>
        <li>Alternatively, you can replace the whole alist functionally:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun set-alist (key value alist)
  "Return a new alist with KEY updated to VALUE."
  (let ((pair (assoc key alist)))
    (if pair
        (progn (setf (cdr pair) value) alist)
        (acons key value alist))))

(setf *grades* (set-alist 'alice 100 *grades*))
*grades* ; =&gt; ((BOB . 90) (ALICE . 100))
</code></pre>
    <br/>
    <br/>

    <li><b>Removing an entry</b></li>
    <br/>
    <ul>
        <li><code>REMOVE</code> or <code>REMOVE-IF</code> can filter entries by key.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(setf *grades*
      (remove 'bob *grades* :key #'car))

*grades* ; =&gt; ((ALICE . 100))
</code></pre>
    <br/>
    <br/>

    <li><b>Traversing an alist</b></li>
<pre><code class="language-lisp line-numbers">(dolist (pair *colors*)
  (format t "~A → ~A~%" (car pair) (cdr pair)))
;; APPLE → RED
;; BANANA → YELLOW
;; GRAPE → PURPLE
</code></pre>
    <br/>
    <br/>

    <li><b>Nested alists</b></li>
    <br/>
    <ul>
        <li>Since each value can itself be another alist, you can represent hierarchical data easily.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *library*
  '((fiction . ((1984        . "Orwell")
                (brave-new-world . "Huxley")))
    (science . ((cosmos . "Sagan")
                (origin . "Darwin")))))

(assoc 'fiction *library*)
;; =&gt; (FICTION ( (1984 . "Orwell") (BRAVE-NEW-WORLD . "Huxley") ))

(assoc '1984 (cdr (assoc 'fiction *library*)))
;; =&gt; (1984 . "Orwell")
</code></pre>
    <br/>
    <br/>

    <li><b>Comparison: alist vs plist vs hash-table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Structure</th>
                <th>Form</th>
                <th>Lookup</th>
                <th>Mutability</th>
                <th>Best for</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>Alist</b></td>
                <td><code>((key . val) ...)</code></td>
                <td>Linear (O(n)) via <code>assoc</code></td>
                <td>Easy with <code>rplacd</code> or <code>acons</code></td>
                <td>Small, dynamic mappings</td>
            </tr>
            <tr>
                <td><b>Plist</b></td>
                <td><code>(key1 val1 key2 val2 ...)</code></td>
                <td>Linear (O(n)) via <code>getf</code></td>
                <td>Easy but less structured</td>
                <td>Keyword options, symbol metadata</td>
            </tr>
            <tr>
                <td><b>Hash table</b></td>
                <td><code>#&lt;HASH-TABLE&gt;</code></td>
                <td>Constant (O(1)) average</td>
                <td>Mutable with <code>gethash</code>, <code>setf</code></td>
                <td>Large datasets, fast lookup</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>

    <li><b>Advanced: destructive updates with RPLACA and RPLACD</b></li>
    <br/>
    <ul>
        <li>Every pair in an alist is a cons cell, so you can modify it directly.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defparameter *pair* (assoc 'apple *colors*))
(rplacd *pair* 'green)   ; change value to GREEN
*colors* ; =&gt; ((APPLE . GREEN) (BANANA . YELLOW) (GRAPE . PURPLE))
</code></pre>
    <br/>
    <ul>
        <li>These operations mutate structure in place — use with care.</li>
    </ul>
    <br/>
    <br/>

    <li><b>Quick utility examples</b></li>
<pre><code class="language-lisp line-numbers">(defun alist-keys (alist)
  (mapcar #'car alist))

(defun alist-values (alist)
  (mapcar #'cdr alist))

(alist-keys *colors*)   ; =&gt; (APPLE BANANA GRAPE)
(alist-values *colors*) ; =&gt; (GREEN YELLOW PURPLE)
</code></pre>
    <br/>
    <br/>

    <li><mark>Summary</mark></li>
    <ul>
        <br/>
        <li>An <b>alist</b> is a list of cons pairs representing key–value bindings.</li>
        <br/>
        <li>Use <code>assoc</code> to look up, <code>acons</code> to add, and <code>rplacd</code> or <code>remove</code> to update or delete.</li>
        <br/>
        <li>Alists are simple, readable, and perfect for small tables or configuration data.</li>
        <br/>
        <li>For larger or performance-critical datasets, use <code>hash-table</code> instead.</li>
        <br/>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Symbol Properties and <code>SYMBOL-PLIST</code></h3>
<ol>
    <li><b>Every symbol has its own property list</b></li>
    <br/>
    <ul>
        <li>Each Lisp symbol can carry its own attached <b>property list</b> (short: <b>plist</b>).</li>
        <br/>
        <li>This plist is a list of alternating keys and values:
            <code>(key1 val1 key2 val2 ...)</code></li>
        <br/>
        <li>It’s accessed through <code>(symbol-plist 'symbol-name)</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(symbol-plist 'apple)
;; =&gt; NIL  (no properties yet)
</code></pre>
    <br/>
    <br/>


    <li><b>Setting properties with <code>setf</code></b></li>
    <br/>
    <ul>
        <li>You can directly assign a plist to a symbol:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(setf (symbol-plist 'apple)
      '(:color "red" :taste "sweet" :origin "Poland"))

(symbol-plist 'apple)
;; =&gt; (:COLOR "red" :TASTE "sweet" :ORIGIN "Poland")
</code></pre>
    <br/>
    <br/>


    <li><b>Reading properties with <code>get</code> or <code>getf</code></b></li>
    <br/>
    <ul>
        <li><code>get</code> is the traditional function specialized for symbol plists:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(get 'apple :color)
;; =&gt; "red"

(get 'apple :origin)
;; =&gt; "Poland"

(get 'apple :price)
;; =&gt; NIL   ; key not present
</code></pre>
    <br/>
    <ul>
        <li>You can also operate on the plist directly using <code>getf</code>:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(getf (symbol-plist 'apple) :taste)
;; =&gt; "sweet"
</code></pre>
    <br/>
    <br/>


    <li><b>Changing and adding properties</b></li>
    <br/>
    <ul>
        <li>Simply use <code>setf</code> with <code>get</code> or <code>getf</code>:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(setf (get 'apple :taste) "sour")
(get 'apple :taste)
;; =&gt; "sour"

(setf (getf (symbol-plist 'apple) :season) 'autumn)
(symbol-plist 'apple)
;; =&gt; (:COLOR "red" :TASTE "sour" :ORIGIN "Poland" :SEASON AUTUMN)
</code></pre>
    <br/>
    <br/>


    <li><b>Removing a property</b></li>
    <br/>
    <ul>
        <li>Use <code>remprop</code> for symbol plists, or <code>remf</code> for generic plists.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(remprop 'apple :origin)
(symbol-plist 'apple)
;; =&gt; (:COLOR "red" :TASTE "sour" :SEASON AUTUMN)

(remf (symbol-plist 'apple) :taste)
(symbol-plist 'apple)
;; =&gt; (:COLOR "red" :SEASON AUTUMN)
</code></pre>
    <br/>
    <br/>


    <li><b>Common pattern: attaching metadata to functions or symbols</b></li>
    <br/>
    <ul>
        <li>Because every symbol can carry its own plist, you can easily attach metadata to your functions, variables, or constants.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun compute-tax (price)
  (* price 0.19))

(setf (get 'compute-tax :author) "Hwangfucius")
(setf (get 'compute-tax :category) "Logic Study")

(format t "Author: ~A~%" (get 'compute-tax :author))
(format t "Category: ~A~%" (get 'compute-tax :category))
;; Author: Hwangfucius
;; Category: Logic Study
</code></pre>
    <br/>
    <ul>
        <li>Think of it as attaching "tags" or "annotations" to the symbol object itself.</li>
    </ul>
    <br/>
    <br/>


    <li><b>PLIST structure recap</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Example</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Raw plist</td>
                <td><code>'(:color "red" :taste "sweet")</code></td>
                <td>Linear key-value sequence</td>
            </tr>
            <tr>
                <td>Attached to symbol</td>
                <td><code>(symbol-plist 'apple)</code></td>
                <td>Property list stored within that symbol object</td>
            </tr>
            <tr>
                <td>Read</td>
                <td><code>(get 'apple :color)</code></td>
                <td>Retrieve value</td>
            </tr>
            <tr>
                <td>Write</td>
                <td><code>(setf (get 'apple :taste) "sour")</code></td>
                <td>Modify or add</td>
            </tr>
            <tr>
                <td>Delete</td>
                <td><code>(remprop 'apple :taste)</code></td>
                <td>Remove entry</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Iterating over a symbol’s plist</b></li>
    <br/>
<pre><code class="language-lisp line-numbers">(let ((plist (symbol-plist 'apple)))
  (loop for (key val) on plist by #'cddr
        do (format t "~A → ~A~%" key val)))

;; :COLOR → red
;; :SEASON → AUTUMN
</code></pre>
    <br/>
    <br/>

    <li><b>Comparing symbol plist with external alists</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Symbol plist</th>
                <th>Alist</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Storage form</td>
                <td><code>(key1 val1 key2 val2 ...)</code></td>
                <td><code>((key1 . val1) (key2 . val2))</code></td>
            </tr>
            <tr>
                <td>Attached to</td>
                <td>A single symbol object</td>
                <td>Any variable holding list</td>
            </tr>
            <tr>
                <td>Access functions</td>
                <td><code>get</code>, <code>remprop</code></td>
                <td><code>assoc</code>, <code>acons</code></td>
            </tr>
            <tr>
                <td>Use case</td>
                <td>Metadata or attributes for a symbol</td>
                <td>External key-value mapping</td>
            </tr>
        </tbody>
    </table>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Packages, INTERN, and Namespaces</h3>
<ol>
    <li><b>What is a package?</b></li>
    <br/>
    <ul>
        <li>A <b>package</b> in Common Lisp is a <u>namespace</u> for symbols.</li>
        <br/>
        <li>It controls:
            <ul>
                <br/>
                <li>Which symbols belong to it.</li>
                <li>Which symbols it can "see" from other packages.</li>
                <li>How names are resolved when you type <code>foo</code>, <code>car</code>, etc.</li>
                <br/>
            </ul>
        </li>
        <li>Examples of built-in packages:
            <ul>
                <li><code>COMMON-LISP</code> → core language (functions/macros like <code>car</code>, <code>if</code>, <code>let</code>)</li>
                <li><code>COMMON-LISP-USER</code> → default user package in many REPLs</li>
                <li><code>KEYWORD</code> → where keyword symbols like <code>:foo</code> live</li>
            </ul>
        </li>
    </ul>
    <br/>
<pre><code class="language-lisp line-numbers">(symbol-name 'car)        ; "CAR"
(symbol-package 'car)     ; #&lt;PACKAGE "COMMON-LISP"&gt;
(symbol-package :hello)   ; #&lt;PACKAGE "KEYWORD"&gt;
</code></pre>
    <br/>
    <br/>


    <li><b>Creating a custom package with MAKE-PACKAGE</b></li>
    <br/>
    <ul>
        <li>You can create a new package at runtime using <code>MAKE-PACKAGE</code>.</li>
        <li>Basic form:
            <br/><code>(make-package "NAME" &amp;key :use)</code></li>
    </ul>
<pre><code class="language-lisp line-numbers">(make-package "MY-APP" :use '("COMMON-LISP"))
;; =&gt; #&lt;PACKAGE "MY-APP"&gt;
</code></pre>
    <br/>
    <ul>
        <li><code>:use '("COMMON-LISP")</code> means:
            <ul>
                <br/>
                <li>Inside <code>MY-APP</code>, you can refer to <code>CAR</code>, <code>IF</code>, etc. without writing <code>CL:CAR</code>, <code>CL:IF</code>.</li>
                <br/>
            </ul>
        </li>
    </ul>
    <br/>
    <br/>


    <li><b>INTERN: creating or finding a symbol inside a package</b></li>
    <br/>
    <ul>
        <li><code>INTERN</code> takes a string and a package and returns a symbol (and a status).</li>
    </ul>
<pre><code class="language-lisp line-numbers">(intern "FOO" "MY-APP")
;; first time =&gt; MY-APP::FOO, NIL
;; later      =&gt; MY-APP::FOO, :INTERNAL
;; return values typically: symbol, status
</code></pre>
    <br/>
    <ul>
        <li>If a symbol named <code>"FOO"</code> already exists in that package, it returns the existing symbol.</li>
        <br/>
        <li>If not, it creates a new symbol with that name in that package.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(multiple-value-bind (sym status) (intern "FOO" "MY-APP")
  (list sym status))
;; =&gt; (MY-APP::FOO :INTERNAL)  ; for a fresh symbol
</code></pre>
    <br/>
    <br/>


    <li><b>Reading and printing package-qualified symbols</b></li>
    <br/>
    <ul>
        <li>When you see <code>MY-APP::FOO</code>, that is:
            <ul>
                <br/>
                <li>Package: <code>MY-APP</code></li>
                <br/>
                <li>Symbol name: <code>FOO</code></li>
                <br/>
            </ul>
        </li>
        <li>There are two separators:
            <ul>
                <br/>
                <li><code>MY-APP:FOO</code> → <b>external</b> symbol</li>
                <br/>
                <li><code>MY-APP::FOO</code> → <b>internal</b> symbol</li>
                <br/>
            </ul>
        </li>
    </ul>
    <br/>

    <table>
        <thead>
            <tr>
                <th>Syntax</th>
                <th>Meaning</th>
                <th>When used</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>pkg:foo</code></td>
                <td>Refer to <b>exported</b> (public) symbol <code>FOO</code> in package <code>PKG</code>.</td>
                <td>Normal "public API" usage.</td>
            </tr>
            <tr>
                <td><code>pkg::foo</code></td>
                <td>Refer to <b>internal</b> symbol <code>FOO</code> in package <code>PKG</code>.</td>
                <td>Peeking into implementation details.</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>IN-PACKAGE: changing the current package</b></li>
    <br/>
    <ul>
        <li><code>IN-PACKAGE</code> changes the package where unqualified symbols are read and interned.</li>
        <li>Typically used at the top of a source file.</li>
    </ul>
<pre><code class="language-lisp line-numbers">;; in a .lisp file:

(in-package :my-app)

(defparameter *x* 10)  ; *X* is really MY-APP::*X*
</code></pre>
    <br/>
    <ul>
        <li>After <code>(in-package :my-app)</code>, writing <code>*x*</code> means <code>MY-APP::*X*</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>DEFPACKAGE: the usual way to define packages</b></li>
    <br/>
    <ul>
        <li>In real projects, you rarely call <code>MAKE-PACKAGE</code> directly in code; you use <code>DEFPACKAGE</code> in a system definition.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defpackage :my-app
  (:use :cl)
  (:export :start-app :*version*))

(in-package :my-app)

(defparameter *version* "1.0.0")

(defun start-app ()
  (format t "Starting app v~A~%" *version*))
</code></pre>
    <br/>
    <ul>
        <li><code>:use :cl</code> → import <code>COMMON-LISP</code> symbols as defaults.</li>
        <li><code>:export</code> → make these symbols public (<code>my-app:start-app</code>, <code>my-app:*version*</code>).</li>
    </ul>
    <br/>
    <br/>


    <li><b>FIND-SYMBOL: look up symbols by name and package</b></li>
    <br/>
    <ul>
        <li><code>FIND-SYMBOL</code> is like the read-only cousin of <code>INTERN</code>: it only finds, does not create.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(find-symbol "FOO" "MY-APP")
;; =&gt; MY-APP::FOO, :INTERNAL   or NIL, NIL if not present
</code></pre>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Function</th>
                <th>Creates new symbol?</th>
                <th>Returns</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>intern</code></td>
                <td>Yes, if not already present</td>
                <td>Symbol, status (<code>:internal</code> / <code>:external</code> / <code>:inherited</code>)</td>
            </tr>
            <tr>
                <td><code>find-symbol</code></td>
                <td>No</td>
                <td>Symbol or <code>NIL</code>, plus same status</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>SYMBOL-NAME and SYMBOL-PACKAGE</b></li>
    <br/>
    <ul>
        <li>You can inspect a symbol’s name (string) and home package.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(multiple-value-bind (sym status) (intern "FOO" "MY-APP")
  (list (symbol-name sym)
        (symbol-package sym)
        status))
;; =&gt; ("FOO" #&lt;PACKAGE "MY-APP"&gt; :INTERNAL)
</code></pre>
    <br/>
    <ul>
        <li>To convert a symbol back to a string: <code>(symbol-name 'my-app::foo)</code> → <code>"FOO"</code>.</li>
        <li>To create a symbol from a string: <code>(intern "FOO" "MY-APP")</code>.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Exporting and importing symbols</b></li>
    <br/>
    <ul>
        <li>To make a symbol "public" from a package, call <code>EXPORT</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(in-package :my-app)

(defvar *secret* 42)
(export '*secret*)

(symbol-package '*secret*) ; =&gt; #&lt;PACKAGE "MY-APP"&gt;

;; From another package / REPL:
MY-APP:*SECRET*  ; use single colon for exported symbol
</code></pre>
    <br/>
    <ul>
        <li>To "use" exported symbols from another package without writing the prefix every time, use <code>USE-PACKAGE</code>:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(use-package :my-app)
*secret* ; now accessible directly (if no name conflict)
</code></pre>
    <br/>
    <br/>


    <li><mark>Summary</mark></li>
    <ul>
        <br/>
        <li>A <b>package</b> is a namespace that owns symbols and controls visibility.</li>
        <br/>
        <li><code>MAKE-PACKAGE</code> creates a package; <code>DEFPACKAGE</code> is the usual, declarative way.</li>
        <br/>
        <li><code>INTERN</code> creates/finds a symbol in a package from a string.</li>
        <br/>
        <li><code>FIND-SYMBOL</code> only finds, never creates.</li>
        <br/>
        <li><code>pkg:foo</code> refers to an <b>exported</b> symbol; <code>pkg::foo</code> refers to an internal one.</li>
        <br/>
        <li><code>IN-PACKAGE</code> switches the "current" package for reading and interning symbols.</li>
        <br/>
        <li><code>EXPORT</code> and <code>USE-PACKAGE</code> control what becomes your public API.</li>
        <br/>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3><code>my-app:start-app</code> VS <code>my-app::start-app</code></h3>
<ol>
    <li><b>Recap: exported vs internal symbols</b></li>
    <br/>
    <ul>
        <li>When you define a package with <code>DEFPACKAGE</code>, you can choose which symbols are <b>exported</b> (public) and which remain <b>internal</b> (private).</li>
        <br/>
        <li>Example:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defpackage :my-app
  (:use :cl)
  (:export :start-app :*version*))

(in-package :my-app)

(defparameter *version* "1.0.0")

(defun start-app ()
  (format t "Starting app v~A~%" *version*))
</code></pre>
    <br/>
    <ul>
        <li>Here, <code>start-app</code> and <code>*version*</code> are <b>exported</b> from <code>MY-APP</code>.</li>
        <br/>
        <li>Other symbols you define but don’t list in <code>:export</code> stay internal.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Single colon: <code>pkg:symbol</code> -> exported only</b></li>
    <br/>
    <ul>
        <li><code>pkg:symbol</code> means: "Use the <b>exported</b> symbol named <code>SYMBOL</code> from package <code>PKG</code>."</li>
        <br/>
        <li>If that symbol isn’t exported, you get a <b>reader error</b> when loading/compiling code.</li>
    </ul>

    <br/>
    <br/>

    <ul>
    <li>Example (assuming <code>start-app</code> is <u>not</u> exported):</li>
<pre><code class="language-lisp line-numbers">;; Suppose:
(defpackage :my-app
  (:use :cl))         ; no :export here

(in-package :my-app)

(defun start-app ()
  (format t "Starting app!~%"))


;; From CL-USER:
CL-USER&gt; (my-app:start-app)
;; =&gt; Reader error:
;;    The symbol "START-APP" is not exported from package "MY-APP".
</code></pre>
    <br/>
        <li>So: <b>one colon</b> works only for <b>exported</b> (public) API symbols.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Double colon: <code>pkg::symbol</code> → internal or external</b></li>
    <br/>
    <ul>
        <li><code>pkg::symbol</code> means: "Give me the symbol named <code>SYMBOL</code> in package <code>PKG</code>, even if it’s internal."</li>
        <br/>
        <li>It can see both:
            <ul>
                <li>exported symbols</li>
                <li>internal (non-exported) symbols</li>
            </ul>
        </li>
    </ul>

    <p>Continuing the same example (no <code>:export</code>):</p>
<pre><code class="language-lisp line-numbers">CL-USER&gt; (my-app::start-app)
Starting app!
NIL
</code></pre>
    <br/>
    <ul>
        <li><code>my-app::start-app</code> works even though <code>start-app</code> was not exported.</li>
        <br/>
        <li>This is how you can "peek inside" another package’s internal implementation.</li>
    </ul>
    <br/>
    <br/>


    <li><b>What if the symbol doesn’t exist?</b></li>
    <br/>
    <ul>
        <li>If you typo the name with <code>pkg::typo-name</code>, the reader will <b>intern a new symbol</b> in that package:</li>
    </ul>
<pre><code class="language-lisp line-numbers">CL-USER&gt; 'my-app::start-ap
;; =&gt; MY-APP::START-AP   ; a new symbol was created

CL-USER&gt; (my-app::start-ap)
;; =&gt; Undefined-function error at runtime
</code></pre>
    <br/>
    <ul>
        <li>So <code>::</code> will not throw a reader error — it either finds the symbol or creates a new internal one.</li>
        <br/>
        <li>If it’s new and you try to call it as a function, you’ll get a normal <b>undefined function</b> runtime error.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Export vs internal access: behavior table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Symbol status in <code>MY-APP</code></th>
                <th>Form</th>
                <th>Result</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Exported</td>
                <td><code>my-app:start-app</code></td>
                <td>✅ Works</td>
            </tr>
            <tr>
                <td>Exported</td>
                <td><code>my-app::start-app</code></td>
                <td>✅ Also works (can still use internal-access syntax)</td>
            </tr>
            <tr>
                <td>Internal (not exported)</td>
                <td><code>my-app:start-app</code></td>
                <td>❌ Reader error: not exported</td>
            </tr>
            <tr>
                <td>Internal (not exported)</td>
                <td><code>my-app::start-app</code></td>
                <td>✅ Works (internal symbol access)</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Best practice / style</b></li>
    <br/>
    <ul>
        <li>Use <b>one colon</b> (<code>pkg:foo</code>) when you are calling the public API of another package.</li>
        <br/>
        <li>Use <b>two colons</b> (<code>pkg::foo</code>) only when:
            <ul>
                <br/>
                <li>You're debugging, testing, or exploring.</li>
                <br/>
                <li>You intentionally want to reach into private internals (with the risk that they may change).</li>
                <br/>
            </ul>
        </li>
        <br/>
        <li>Library authors should clearly <code>:export</code> only the symbols they want others to rely on.</li>
    </ul>
    <br/>
    <br/>


    <li><mark>Summary</mark></li>
    <ul>
        <br/>
        <li>If you don't <code>:export</code> <code>start-app</code> from <code>MY-APP</code>:
            <ul>
                <br/>
                <li><code>my-app:start-app</code> → <b>error</b> (not exported).</li>
                <br/>
                <li><code>my-app::start-app</code> → <b>works</b>, because it can access internal symbols.</li>
                <br/>
            </ul>
        </li>
        <br/>
        <li>Single colon = "public, exported symbol only".</li>
        <br/>
        <li>Double colon = "any symbol (internal or external) with that name in the package."</li>
        <br/>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Package Designators: <code>:my-app</code> VS <code>"MY-APP"</code></h3>
<ol>
    <li><b>The confusion</b></li>
    <br/>
    <ul>
        <li>You see code like this:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defpackage :my-app
  (:use :cl))

(in-package :my-app)

(find-symbol "FOO" "MY-APP")
(intern "BAR" "MY-APP")
</code></pre>
    <br/>
    <ul>
        <li>Sometimes the package is written as <code>:my-app</code> (a keyword symbol).</li>
        <li>Sometimes as <code>"MY-APP"</code> (a string).</li>
        <li>So... <b>which is correct</b>, and why both work?</li>
    </ul>
    <br/>
    <br/>


    <li><b>Package designator: multiple types allowed</b></li>
    <br/>
    <ul>
        <li>Many functions that work with packages (like <code>FIND-SYMBOL</code>, <code>INTERN</code>, <code>FIND-PACKAGE</code>) accept a <b>package designator</b>.</li>
        <br/>
        <li>A <b>package designator</b> can be:
            <ul>
                <br/>
                <li>a <b>string</b> → interpreted as the package <b>name</b> (case usually upcased)</li>
                <br/>
                <li>a <b>symbol</b> → its <code>symbol-name</code> is used as the package name</li>
                <br/>
                <li>a <b>package object</b> itself</li>
                <br/>
            </ul>
        </li>
        <li>So all of these are valid and often equivalent:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(find-symbol "FOO" "MY-APP")
(find-symbol "FOO" :my-app)
(find-symbol "FOO" (find-package :my-app))
</code></pre>
    <br/>
    <br/>


    <li><b>Why <code>:my-app</code> in <code>DEFPACKAGE</code> and <code>IN-PACKAGE</code>?</b></li>
    <br/>
    <ul>
        <li><code>DEFPACKAGE</code> and <code>IN-PACKAGE</code> are usually written at <b>read-time</b> in source files, and it's idiomatic to use a <b>keyword symbol</b> as the package name:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defpackage :my-app
  (:use :cl)
  (:export :start-app))

(in-package :my-app)
</code></pre>
    <br/>
    <ul>
        <li>Here:
            <ul>
                <br/>
                <li><code>:my-app</code> is a symbol in the <code>KEYWORD</code> package.</li>
                <br/>
                <li>Its symbol-name is <code>"MY-APP"</code>.</li>
                <br/>
                <li><code>DEFPACKAGE</code> uses that name to create a package whose name is <code>"MY-APP"</code>.</li>
                <br/>
            </ul>
        </li>
        <li>You could also write:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defpackage "MY-APP"
  (:use "CL"))
(in-package "MY-APP")
</code></pre>
    <br/>
    <ul>
        <li>But the keyword style (<code>:my-app</code>, <code>:cl</code>) is shorter and more common.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Why <code>"MY-APP"</code> in <code>FIND-SYMBOL</code> / <code>INTERN</code> examples?</b></li>
    <br/>
    <ul>
        <li>Because those functions are being shown in their most "raw" form: <code>(find-symbol name package-name-string)</code>.</li>
        <br/>
        <li>But remember: they accept <b>any package designator</b>, so all of these are equivalent:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(find-symbol "FOO" "MY-APP")
(find-symbol "FOO" :my-app)
(find-symbol "FOO" (find-package "MY-APP"))
</code></pre>
    <br/>
    <ul>
        <li>The choice is mostly style — many people prefer keywords in code:</li>
    </ul>
<pre><code class="language-lisp line-numbers">(intern "FOO" :my-app)
(find-symbol "BAR" :my-app)
</code></pre>
    <br/>
    <br/>


    <li><b>Symbol name vs package name</b></li>
    <br/>
    <ul>
        <li>When you write <code>:my-app</code>, you are writing a <b>symbol literal</b> whose <b>name</b> is <code>"MY-APP"</code>.</li>
        <br/>
        <li>The package system just uses that name string.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(symbol-name :my-app)
;; =&gt; "MY-APP"

(find-package :my-app)
;; =&gt; #&lt;PACKAGE "MY-APP"&gt;

(find-package "MY-APP")
;; =&gt; #&lt;PACKAGE "MY-APP"&gt;
</code></pre>
    <br/>
    <br/>


    <li><b>Side-by-side comparison</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Form</th>
                <th>Type</th>
                <th>What package functions see</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>"MY-APP"</code></td>
                <td>String</td>
                <td>Package name string = <code>"MY-APP"</code></td>
            </tr>
            <tr>
                <td><code>:my-app</code></td>
                <td>Keyword symbol</td>
                <td>Use <code>(symbol-name :my-app)</code> → <code>"MY-APP"</code></td>
            </tr>
            <tr>
                <td><code>#&lt;PACKAGE "MY-APP"&gt;</code></td>
                <td>Package object</td>
                <td>Used directly</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Practical guidelines</b></li>
    <br/>
    <ul>
        <li>In <b>DEFPACKAGE</b> and <b>IN-PACKAGE</b> forms:
            <ul>
                <br/>
                <li>Prefer keywords: <code>:my-app</code>, <code>:cl</code>.</li>
                <br/>
            </ul>
        </li>
        <li>In functions like <code>FIND-SYMBOL</code>, <code>INTERN</code>, <code>FIND-PACKAGE</code>:
            <ul>
                <br/>
                <li>You can use either strings <b>or</b> symbols. Keywords are convenient:</li>
                <br/>
            </ul>
        </li>
    </ul>
<pre><code class="language-lisp line-numbers">(intern "FOO" :my-app)          ; idiomatic
(intern "FOO" "MY-APP")         ; also valid
(intern "FOO" (find-package :my-app)) ; most explicit
</code></pre>
    <br/>
    <br/>


    <li><mark>Summary</mark></li>
    <ul>
        <br/>
        <li>Many package-related functions accept a <b>package designator</b>: string, symbol, or package.</li>
        <br/>
        <li><code>:my-app</code> is a symbol whose name is <code>"MY-APP"</code> — both refer to the same package name.</li>
        <br/>
        <li>That’s why you see:
            <ul>
                <br/>
                <li><code>(defpackage :my-app ...)</code> — symbol designator.</li>
                <br/>
                <li><code>(find-symbol "FOO" "MY-APP")</code> — string designator.</li>
                <br/>
            </ul>
        </li>
        <br/>
        <li>In your own code, you can safely write <code>(find-symbol "FOO" :my-app)</code> if you prefer the keyword style.</li>
        <br/>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="multiple-values">Returning Multiple Values</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>In Common Lisp, a function can return <u>more than one value</u> directly.</li>
        <br/>
        <li>Unlike many languages that pack results into a list or tuple,
            Lisp's multiple-value system is <b>native</b> and <b>efficient</b>.</li>
        <br/>
        <li>You create them with <code>VALUES</code> and retrieve them with <code>MULTIPLE-VALUE-BIND</code> or similar macros.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(values 10 20 30)
;; =&gt; 10
;; (prints only first value in REPL, but others still exist!)
</code></pre>
    <br/>
    <br/>


    <li><b>Creating multiple values with VALUES</b></li>
    <br/>
    <ul>
        <li><code>(values a b c)</code> returns all of <code>a</code>, <code>b</code>, and <code>c</code> as separate values.</li>
        <br/>
        <li>When the caller expects only one value, <b>only the first</b> is used.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun divide (x y)
  (values (floor (/ x y))  ; quotient
          (mod x y)))      ; remainder

(divide 10 3)
;; =&gt; 3
;; (prints 3, but second value 1 exists)

(multiple-value-bind (q r) (divide 10 3)
  (list q r))
;; =&gt; (3 1)
</code></pre>
    <br/>
    <br/>


    <li><b>MULTIPLE-VALUE-BIND: unpacking values</b></li>
    <br/>
    <ul>
        <li><code>multiple-value-bind</code> binds each returned value to a variable.</li>
        <br/>
        <li>Extra values beyond the variable list are ignored; missing ones become <code>NIL</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(multiple-value-bind (a b c) (values 1 2)
  (list a b c))
;; =&gt; (1 2 NIL)
</code></pre>
    <br/>
    <ul>
        <li>This is similar to destructuring assignment in other languages, but built into the function return system.</li>
    </ul>
    <br/>
    <br/>


    <li><b>MULTIPLE-VALUE-LIST</b></li>
    <br/>
    <ul>
        <li><code>multiple-value-list</code> collects all values into a single list.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(multiple-value-list (values 1 2 3))
;; =&gt; (1 2 3)
</code></pre>
    <br/>
    <ul>
        <li>This is handy when you want to store or iterate over returned values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>MULTIPLE-VALUE-CALL</b></li>
    <br/>
    <ul>
        <li><code>multiple-value-call</code> applies a function to all values produced by its arguments.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(multiple-value-call #'list (values 'a 'b 'c))
;; =&gt; (A B C)
</code></pre>
    <br/>
    <ul>
        <li>It’s like calling <code>(apply #'list '(a b c))</code>, but directly supports multiple-value returns.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Ignoring extra values</b></li>
    <br/>
    <ul>
        <li>When a function returns multiple values but you only care about one, Lisp automatically ignores the rest.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun test ()
  (values 1 2 3))

(+ (test) 5)
;; =&gt; 6   ; only first value 1 used
</code></pre>
    <br/>
    <ul>
        <li>This makes multiple-value functions backward compatible with single-value code.</li>
    </ul>
    <br/>
    <br/>


    <li><b>VALUES-LIST</b></li>
    <br/>
    <ul>
        <li>The opposite of <code>multiple-value-list</code>: it turns a list into multiple values.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(values-list '(10 20 30))
;; =&gt; 10, 20, 30
</code></pre>
    <br/>
    <ul>
        <li>Used internally by macros that forward unknown numbers of return values.</li>
    </ul>
    <br/>
    <br/>


    <li><b>Key Functions and Macros Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Purpose</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>values</code></td>
                <td>Return multiple values</td>
                <td><code>(values a b c)</code></td>
            </tr>
            <tr>
                <td><code>multiple-value-bind</code></td>
                <td>Bind multiple results to variables</td>
                <td><code>(multiple-value-bind (x y) (func) ...)</code></td>
            </tr>
            <tr>
                <td><code>multiple-value-list</code></td>
                <td>Collect values into a list</td>
                <td><code>(multiple-value-list (func))</code></td>
            </tr>
            <tr>
                <td><code>values-list</code></td>
                <td>Return list elements as multiple values</td>
                <td><code>(values-list '(1 2 3))</code></td>
            </tr>
            <tr>
                <td><code>multiple-value-call</code></td>
                <td>Call function with all returned values</td>
                <td><code>(multiple-value-call #'list (values 1 2 3))</code></td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Comparison to lists and tuples</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Concept</th>
                <th>Multiple Values</th>
                <th>List</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Representation</td>
                <td>Native runtime feature (not a list)</td>
                <td>Explicit object</td>
            </tr>
            <tr>
                <td>Memory allocation</td>
                <td>No consing needed</td>
                <td>Creates a list object</td>
            </tr>
            <tr>
                <td>Efficiency</td>
                <td>Very fast</td>
                <td>Slower for temporary data</td>
            </tr>
            <tr>
                <td>Backward compatibility</td>
                <td>Only first value used if context ignores others</td>
                <td>Always one object</td>
            </tr>
        </tbody>
    </table>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Currying vs Closures</h3>
<ol>
    <li><b>Closures</b> — Functions that remember</li>
    <br/>
    <ul>
        <li>A <b>closure</b> is a function that "remembers" variables from the environment where it was created.</li>
        <br/>
        <li>Even after that environment is gone, the function retains access to those variables — they are <b>closed over</b>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun make-adder (n)
  "Return a function that adds N to its argument."
  #'(lambda (x)
      (+ x n)))

(setq add5 (make-adder 5))
(funcall add5 10)   ; =&gt; 15
(funcall add5 100)  ; =&gt; 105
</code></pre>
    <br/>
    <ul>
        <li>Here <code>make-adder</code> returns a function that captures the variable <code>n</code>.</li>
        <li>Each call to <code>make-adder</code> creates a <b>new closure</b> with its own private <code>n</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(setq add2 (make-adder 2))
(setq add10 (make-adder 10))

(funcall add2 3)   ; =&gt; 5
(funcall add10 3)  ; =&gt; 13
</code></pre>
    <br/>
    <ul>
        <li>This pattern is common in Lisp — functions that "carry their environment" with them.</li>
    </ul>
    <br/>
    <br/>
    <br/>
    <br/>


    <li><b>Currying</b> — Functions that take one argument at a time</li>
    <br/>
    <ul>
        <li><b>Currying</b> is a functional programming transformation that turns a multi-argument function into a chain of single-argument functions.</li>
        <br/>
        <li>Mathematically, a function <code>f(x, y)</code> becomes <code>f(x)(y)</code>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(defun curry (fn)
  "Transform a two-argument function into a curried one."
  #'(lambda (a)
      #'(lambda (b)
          (funcall fn a b))))

(setq curried-add (curry #'+))

(setq add3 (funcall curried-add 3))
(funcall add3 4) ; =&gt; 7
</code></pre>
    <br/>
    <ul>
        <li>Each step returns a new function that "remembers" the previous argument value.</li>
        <li>That’s why currying <b>uses closures under the hood</b>.</li>
    </ul>
<pre><code class="language-lisp line-numbers">((curry #'+) 2 5)
;; =&gt; 7
</code></pre>
    <br/>
    <br/>


    <li><b>Comparison Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Closure</th>
                <th>Currying</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>Definition</b></td>
                <td>Function that captures variables from its environment.</td>
                <td>Transformation turning <code>f(a,b)</code> into <code>f(a)(b)</code>.</td>
            </tr>
            <tr>
                <td><b>Purpose</b></td>
                <td>To preserve data across calls ("remembering" variables).</td>
                <td>To allow partial application and functional chaining.</td>
            </tr>
            <tr>
                <td><b>Changes arity?</b></td>
                <td>No.</td>
                <td>Yes — from many arguments to one-at-a-time functions.</td>
            </tr>
            <tr>
                <td><b>Built with</b></td>
                <td>Lexical scope capture.</td>
                <td>Closures plus function nesting.</td>
            </tr>
            <tr>
                <td><b>Example (Lisp)</b></td>
                <td><code>(make-adder 5)</code></td>
                <td><code>(curry #'+)</code></td>
            </tr>
            <tr>
                <td><b>Analogy</b></td>
                <td>"A backpack that carries its variables."</td>
                <td>"A conveyor belt feeding one argument at a time."</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>


    <li><b>Example side-by-side</b></li>
    <br/>
<pre><code class="language-lisp line-numbers">;; Closure
(defun make-multiplier (factor)
  #'(lambda (x) (* x factor)))

(setq double (make-multiplier 2))
(funcall double 10) ; =&gt; 20


;; Currying
(defun curry (fn)
  #'(lambda (a)
      #'(lambda (b)
          (funcall fn a b))))

(setq curried-mul (curry #'*))
(funcall (funcall curried-mul 2) 10) ; =&gt; 20
</code></pre>
    <br/>
    <ul>
        <li>Both produce the same result — but they represent different ideas.</li>
        <br/>
        <li>The closure <code>make-multiplier</code> keeps a private value <code>factor</code> inside its environment.</li>
        <br/>
        <li>The curried <code>mul</code> transforms multiplication into a series of single-argument calls.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
