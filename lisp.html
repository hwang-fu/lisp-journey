<!-- * * * * * * * * * * * * * * -->
<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        /*color: purple;*/
        font-family: "FiraCode Nerd Font";
        font-size: 11.0
    }
</style>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<script>
</script>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3>How to use SBCL?</h3>
<ol>
    <li>To run a <i>.lisp</i> or <i>.lsp</i> file:<br/><br/>
        <code>sbcl --script &lt;filename&gt;</code></li>
    <br/>
    <br/>
    <li>To load a <i>.lisp</i> or <i>.lsp</i> file:<br/><br/>
        <code>sbcl --load &lt;filename&gt;</code></li>
    <br/>
    <br/>
    <li>To load a <i>.lisp</i> or <i>.lsp</i> file inside the SBCL prompt:<br/><br/>
        <code>* (load "hello.lisp")</code></li>
    <br/>
    <br/>
    <li>To quit inside the SBCL prompt:<br/><br/>
        <code>* (quit)</code><br/>
        <code>* (sb-ext:quit)</code></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Hello World in Common Lisp</h3>
<ol>
    <li>Genre 1:<br/><br/>
        <code>(write-line "Hello World!")</code>
    </li>
    <br/>
    <br/>
    <li>Genre 2:
<pre><code>
(defun hello-world()
    (format t "Hello World!"))

(hello-world)
</code></pre>
    </li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Lisp Uses Prefix Notation</h3>
<ol>
    <li>In prefix notation, operators are written before their operands.</li>
<pre><code>
a * (b + c) / d
(/ (* a (+ b c)) d)
</pre></code>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basic Building Blocks in Lisp</h3>
<ol>
    <li>Lisp programs are made of three basic building blocks.</li>
    <br/>
    <ul>
        <li>atom</li>
        <br/>
        <li>list</li>
        <br/>
        <li>string</li>
        <br/>
    </ul>
    <br/>
    <br/>
    <li>An <b>atom</b> is a number or a string of contiguous characters.</li>
<pre><code>
    hello-from-lisp
    12300009
    *hello*
    block#123
    abc123
</code></pre>
    <br/>
    <br/>
    <li>A <b>list</b> is a sequence of atoms and other lists enclosed in parentheses.</li>
<pre><code>
    (this is a list)
    (a (a b c) d e f)
    (Sun Mon Tue Wed Thu Fri Sat)
    ( )
</code></pre>
    <br/>
    <br/>
    <li>A <b>string</b> is a group of characters enclosed in double quotation mark ( " )</li>
<pre><code>
    "here is a string"
    "hello"
    "Please enter a number:"
    " "
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Comments</h3>
<ol>
    <li>The semicolon <code>;</code> indicates a line-comment.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Data Types</h3>
<ol>
    <li>Lisp data types can be categorized as:</li>
    <ul>
        <br/>
        <li>Scalar types (e.g., number, characters, symbols, ...)</li>
        <br/>
        <li>Data structures (e.g., list, vector, bit-vector, ...)</li>
    </ul>
    <br/>
    <br/>
    <li>The <code>type-of</code> function returns the data type of a given object.</li>
<pre><code>
    (let ((x 42) (y "hello"))
      (format t "~%The type of X is: ~a" (type-of x))
      (format t "~%The type of Y is: ~a" (type-of y)))
</code></pre>
    <br/>
    <br/>
    <li>Using scalar data types:</li>
<pre><code>
    ; Set values to variables.
    (setq x 10)
    (setq y 34.567)
    (setq ch nil)
    (setq n 123.78)
    (setq bg 11.0e+4)
    (setq r 124/2)
    (setq q (/ 124 2))

    ; Print values of variables.
    (print x)
    (print y)
    (print ch)
    (print n)
    (print bg)
    (print r)
    (print q)
</code></pre>
    <br/>
    <br/>
    <li>Checking types of variables:</li>
<pre><code>
    ; Define variables and set values.
    (defvar x 10)
    (defvar y 34.567)
    (defvar ch nil)
    (defvar n 123.78)
    (defvar bg 11.0e+4)
    (defvar r 124/2)

    ; Print types of variables.
    (print (type-of x))
    (print (type-of y))
    (print (type-of n))
    (print (type-of ch))
    (print (type-of bg))
    (print (type-of r))</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Macro</h3>
<ol>
    <li><b>Macros</b> allow you to extend the syntax of standard Lisp.</li>
    <br/>
    <br/>
    <li>Technically, a macro is a function that takes an s-expression as arguments and returns a Lisp form, which is then evaluated.</li>
    <br/>
    <br/>
    <li>Syntax for defining a named macro:</li>
<pre><code>
    (defmacro &lt;macro-name&gt; (&lt;param-list&gt;)
      "optional document string."
      &lt;body&gt;)
</code></pre>
    <br/>
    <br/>
    <li>Simple Example:</li>
<pre><code>
    (defmacro assign10 (num)
      "A macro that sets a given variable to value 10"
      (setq num 10)
      (print num))

    (setq x 100)
    (print x)       ; 100
    (assign10 x)    ; 10
    (print x)       ; 100
</code></pre>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Variable</h3>
<ol>
    <li>Global variables are generally declared using the <code>defvar</code> construct.</li>
<pre><code>
    ; Define a global variable x with a value of `100`
    (defvar x 100)
    ; Print the value of `x`
    (print x)
</code></pre>
    <br/>
    <br/>
    <li>If there is no type declaration for variables in Lisp, you can directly specify a value for a symbol with the <code>setq</code> construct.</li>
    <br/>
    <br/>
    <li>There are two constructs: <code>let</code> and <code>prog</code> (no longer commonly used) for creating local variables.</li>
    <br/>
    <br/>
    <li>The <code>let</code> construct has the following syntax.<br/>
        If you did NOT include an initial value for a variable, it is assigned <code>nil</code>.</li>
<pre><code>
    (let ((var-1 val-1) (var-2 val-2) ... (var-n val-n))
      &lt;s-expression&gt;
      &lt;s-expression&gt;
      ...)
</code></pre>
    <br/>
    <br/>
    <li>The <code>prog</code> construct has the following syntax.</li>
<pre><code>
    (prog (var-1 var-2 ... var-n)
      &lt;s-expression&gt;
      &lt;s-expression&gt;
      ...)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Escape Character</h3>
<ol>
    <li>A backslash ( <code>\</code> ) escapes the next character, causing it to be included in the string regardless of what it is.</li>
<pre><code>
    "foo"       ; foo
    "f\oo"      ; foo,  because `\o` escapes `o`, treating it iterally like the character `o`.
    "fo\\o"     ; fo\o
    "fo\'o"     ; fo'o
    "fo\"o"     ; fo"o
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Symbol</h3>
<ol>
    <li>There are 10 characters that serve other syntactic purposes can NOT appear in names:</li>
    <br/>
    <ul>
        <li>Open Parentheses (<code> ( </code>)</li>
        <br/>
        <li>Close Parentheses (<code> ) </code>)</li>
        <br/>
        <li>Double Quote (<code> " </code>)</li>
        <br/>
        <li>Single Quote (<code> ' </code>)</li>
        <br/>
        <li>Backtick (<code> ` </code>)</li>
        <br/>
        <li>Comma (<code> , </code>)</li>
        <br/>
        <li>Colon (<code> : </code>)</li>
        <br/>
        <li>Semicolon (<code> ; </code>)</li>
        <br/>
        <li>Backslash (<code> \ </code>)</li>
        <br/>
        <li>Vertical Bar (<code> | </code>)</li>
        <br/>
    </ul>
    <br/>
    <li>If you really want to use those character,
        try to escape them with a backslash (<code> \ </code>)<br/>
        or surround the part of the name containing characters that need escaping
        with vertical bars (<code> | </code>).</li>
<pre><code>
    (defun test\,-lisp ()
      (write-line "Hello, world!"))
    (test\,-lisp)

    (defun |test,-lisp| ()
      (write-line "Hello, world!"))
    (|test,-lisp|)

    (defun | test,-lisp | ()
      (write-line "Hello, world!"))
    (| test,-lisp |)
</code></pre>
    <br/>
    <br/>
    <li><mark>NOTE</mark>:
        The symbol names are <u>case-insensitive</u>,
        it converts all unescaped characters to upper case,
        like <i>foo</i>, <i>Foo</i>, and <i>FOO</i> are the same.<br/>
        However, the f\o\o and |foo| will preserve the case, they are read as <i>foo</i>.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Keyword Symbols</h3>
<ol>
    <li>Keyword symbols are prefixed with a colon (e.g., <code>:name</code>, <code>:id</code>).<br/>
        This prefix automatically makes them part of the <b>KEYWORD</b> package.</li>
    <br/>
    <br/>
    <li>Unlike regular symbols, keyword symbols <u>evaluate to themselves</u>.</li>
<pre><code>
    &gt; :example
    :EXAMPLE

    &gt; :EXample
    :EXAMPLE

    &gt; :\example
    :|eXAMPLE|

    &gt; :a\,b
    :|A,B|

    &gt; :123
    :|123|

    &gt; :123abc
    :123ABC

    &gt; :abc123
    :ABC123

    &gt; :|xyz|
    :|xyz|
</code></pre>
    <br/>
    <br/>
    <li>Keyword symbols are often used as keys in property list.</li>
<pre><code>
    &gt; (setq person '(:name "Alice" :age 20))
    &gt; (getf person :name)
    "Alice"
</code></pre>
<pre><code class="hl-grey-fg">
    ; Btw, (setq person (:name "Alice" :age 20)) is invalid, because Lisp will tru to eval as if :name were a function.
    ; You can also use (setq person (list :name "Alice" :age 20)) instead.
</code></pre>
    <br/>
    <br/>
    <li>Many libraries use keyword symbols for configuration settings.</li>
<pre><code>
    (open "settings.conf", :direction :output)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3><u>if</u> Statement</h3>
<ol>
    <li>Syntax:<code> (if &lt;cond&gt; &lt;then&gt; [&lt;else&gt;]) </code></li>
    <br/>
    <ul>
        <li><i>cond</i> is a condition that eval to either NIL (false) or non-NIL (true).</li>
        <br/>
        <li><i>then</i> is the expression to exec if <i>cond</i> is true.</li>
        <br/>
        <li><i>else</i> is the optional expression to exec if <i>cond</i> is false.</li>
        <br/>
    </ul>
    <br/>
    <br/>
    <li>Basic Example:</li>
<pre><code>
    (if (&gt; 10 5)
      (write-line "10 &gt; 5")
      (write-line "10 &lt;= 5"))
</code></pre>
    <br/>
    <li>Without <i>else</i> expression:</li>
<pre><code>
    (if (= 1 1) (write-line "1 equals 1"))
</code></pre>
    <br/>
    <br/>
    <li>Nested <i>if</i>: </li>
<pre><code>
    (if (&gt; 10 5)
      (if (&lt; 3 4)
        (write-line "10 &gt; 5 and 3 &lt; 4")
        (write-line "10 &gt; 5 and 3 &gt;= 4"))
      (write-line "10 &lt;= 5"))
</code></pre>
    <br/>
    <br/>
    <li>The <i>if</i> expression returns the result of the evaluated <i>then</i> or <i>else</i> form.</li>
<pre><code>
    (let ((x 10))
      (if (&gt; x 5) (+ x 10) (- x 10)))
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about <u>quote</u></h3>
<ol>
    <li>It is used to prevent an expression from being evaluated.</li>
    <br/>
    <br/>
    <li>Syntax:<br/>
        <code>(quote &lt;expr&gt;)</code> or shorthandly <code>'&lt;expr&gt;</code></li>
    <br/>
    <br/>
    <li>Example Usage:</li>
<pre><code>
    &gt; (quote (+ 1 2))
    (+ 1 2)

    &gt; '(+ 1 2)
    (+ 1 2)

    &gt; (+ 1 2)
    3

    &gt; 'a
    A

    &gt; '\a
    |a|
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>True, False and Equality</h3>
<ol>
    <li>The symbol <b>t</b> or <b>T</b> is conventionally treated as true in Common Lisp.<br/><br/>
        <code>(if t "True" "False")</code><code class="hl-grey-fg"> ; returns "True"</code></li>
    <br/>
    <br/>
    <li>The expressions <b>nil</b>, <b>'nil</b>, <b>()</b> and <b>'()</b> are considered false in Common Lisp.<br/><br/>
        <code>(if nil "T" "F")</code><code class="hl-grey-fg"> ; returns "F"</code><br/>
        <code>(if () "T" "F")</code><code class="hl-grey-fg"> ; returns "F"</code><br/>
    </li>
    <br/>
    <br/>
    <li><b>EQ</b> checks whether two values are literally the same object: the same address, same identity.</li>
<pre><code>
    (eq 1000 1000)   ;; might be NIL on some Lisps
    (eq 'foo 'foo)   ;; always T (same interned symbol)
</code></pre>
    <br/>
    <br/>
    <li><b>EQL</b> is just like <b>EQ</b>, but slightly stronger: it also considers numbers and characters with the same value as equal.</li>
<pre><code>
    (eql 1000 1000)  ;; always T
    (eql 1.0 1)      ;; NIL (different types)
    (eql #\A #\A)    ;; T
</code></pre>
    <br/>
    <br/>
    <li><b>EQUAL</b> compares structural lists and strings (and bit-vectors).</li>
<pre><code>
    (equal '(a (b)) '(a (b)))   ;; T
    (equal "Foo" "Foo")         ;; T
    (equal "Foo" "foo")         ;; NIL (case-sensitive)
    (equal 1 1.0)               ;; NIL (numbers must be EQL)
    (equal #\A #\a)             ;; NIL
</code></pre>
    <br/>
    <br/>
    <li><b>EQUALP</b> is more forgiving: case-insensitive for strings and characters, and value comparison for numbers.</li>
<pre><code>
    (equalp "Foo" "foo")        ;; T
    (equalp #\A #\a)            ;; T
    (equalp 1 1.0)              ;; T
    (equalp '(1 "A") #(1 "a"))  ;; T (list vs vector ok; string case ignored)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about <u>cond</u></h3>
<ol>
    <li><b>cond</b> is a versatile conditional construcy used for multi-branch descision-making.
        It is preferred over nested <b>if</b>.</li>
    <br/>
    <br/>
    <li>Syntax:</li>
<pre><code>
    (cond
      (&lt;cond-1&gt; &lt;form-1-1&gt; &lt;form-1-2&gt; ...)
      (&lt;cond-2&gt; &lt;form-2-1&gt; &lt;form-2-2&gt; ...)
      ...
      (t &lt;default-form-1&gt; &lt;default-form-2&gt; ...))
</code></pre>
    <ul>
        <br/>
        <li><b><i>cond-n</i></b> is a condition</li>
        <br/>
        <li><b><i>form</i></b> is one or more expressions to be executed if <b><i>cond-n</i></b> is true.</li>
        <br/>
        <li><b><i>t</i></b> in the end act as a default case.</li>
        <br/>
        <li><mark>NOTE</mark>: only the first <b><i>cond</i></b> which is eval-ed to true is exec-ed.</li>
    </ul>
    <br/>
    <br/>
    <li>Example Usage:</li>
<pre><code>
    (defun categorize-number (x)
      (cond
        ((&lt; x 0) "negative")
        ((&gt; x 0) "positive")
        ((= x 0) "zero")))

    (categorize-number 10)
    (categorize-number -7)
    (categorize-number 0)

    (defun analyze-number (x)
      (cond
        ((&lt; x 0) (format t "~a &lt; 0~%" x) "negative")
        ((&gt; x 0) (format t "~a &gt; 0~%" x) "positive")
        ((= x 0) (format t "x = 0~%") "zero")))

    (analyze-number -3)
    ; it will "-3 &lt; 0" and return "negative"
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Functions</h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>

