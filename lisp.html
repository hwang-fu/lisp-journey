<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Common Lisp</title>

    <!-- Theme (pick any from Prism site) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">

    <!-- Prism core + Lisp language -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;      /* merge borders so you don't get double lines */
        width: 100%;                    /* optional: make it full width */
        font-family: system-ui, sans-serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;      /* light gray header background */
        text-align: left;               /* header text alignment */
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;         /* subtle border color */
        padding: 8px 12px;              /* breathing room */
    }

    tr:nth-child(even) {
        background-color: #fafafa;      /* zebra striping for readability */
    }

    tr:hover {
        background-color: #f0f8ff;      /* light hover highlight */
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-grey-fg {
        color: grey;
    }

    .hl-black-fg {
        color: black;
    }

    .comment {
        color: grey;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px; /* optional: make it a bit thicker */
        text-underline-offset: 2px;     /* optional: move it slightly down */
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;                     /* text */
        background-color: #f6f8fa;          /* bg */
        border: 1px solid #d0d7de;          /* subtle frame */
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;                /* 14px-ish; avoid bare numbers */
        line-height: 1.4;
        font-variant-ligatures:contextual;
    }

    /* Block code container */
    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;       /* match inline bg */
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;                   /* scroll if long */
        tab-size: 4;                      /* adjust as needed */
    }

    /* Code inside pre: remove extra padding/background from inline style */
    pre code {
        display: block;                   /* ensure full-width */
        padding: 0;                       /* pre handles padding */
        background: transparent;          /* avoid double bg */
        border: 0;                        /* avoid double border */
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;                 /* preserve spacing; use pre-wrap to wrap long lines */
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>Common Lisp</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>How to use SBCL?</h3>
<ol>
    <li>To run a <i>.lisp</i> or <i>.lsp</i> file:<br/><br/>
        <code>sbcl --script &lt;filename&gt;</code></li>
    <br/>
    <br/>
    <li>To load a <i>.lisp</i> or <i>.lsp</i> file:<br/><br/>
        <code>sbcl --load &lt;filename&gt;</code></li>
    <br/>
    <br/>
    <li>To load a <i>.lisp</i> or <i>.lsp</i> file inside the SBCL prompt:<br/><br/>
        <code>* (load "hello.lisp")</code></li>
    <br/>
    <br/>
    <li>To quit inside the SBCL prompt:<br/><br/>
        <code>* (quit)</code><br/>
        <code>* (sb-ext:quit)</code></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Hello World in Common Lisp</h3>
<ol>
    <li>Genre 1:<br/><br/>
        <code>(write-line "Hello World!")</code>
    </li>
    <br/>
    <br/>
    <li>Genre 2:
<pre><code class="language-lisp line-numbers">(defun hello-world()
    (format t "Hello World!"))

(hello-world)
</code></pre>
    </li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Lisp Uses Prefix Notation</h3>
<ol>
    <li>In prefix notation, operators are written before their operands.</li>
<pre><code class="language-lisp line-numbers">a * (b + c) / d
(/ (* a (+ b c)) d)
</code></pre>
<br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basic Building Blocks in Lisp</h3>
<ol>
    <li>Lisp programs are made of three basic building blocks.</li>
    <br/>
    <ul>
        <li>atom</li>
        <br/>
        <li>list</li>
        <br/>
        <li>string</li>
        <br/>
    </ul>
    <br/>
    <br/>
    <li>An <b>atom</b> is a number or a string of contiguous characters.</li>
<pre><code class="language-lisp line-numbers">hello-from-lisp
12300009
*hello*
block#123
abc123
</code></pre>
    <br/>
    <br/>
    <li>A <b>list</b> is a sequence of atoms and other lists enclosed in parentheses.</li>
<pre><code class="language-lisp line-numbers">(this is a list)
(a (a b c) d e f)
(Sun Mon Tue Wed Thu Fri Sat)
( )
</code></pre>
    <br/>
    <br/>
    <li>A <b>string</b> is a group of characters enclosed in double quotation mark ( " )</li>
<pre><code class="language-lisp line-numbers">"here is a string"
"hello"
"Please enter a number:"
" "
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Comments</h3>
<ol>
    <li>The semicolon <code>;</code> indicates a line-comment.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Macro</h3>
<ol>
    <li>Technically, a macro is a function that takes an s-expression as arguments and returns a Lisp form, which is then evaluated.</li>
    <br/>
    <br/>
    <li>Syntax for defining a named macro:</li>
<pre><code class="language-lisp line-numbers">(defmacro &lt;macro-name&gt; (&lt;param-list&gt;)
  "optional document string."
  &lt;body&gt;)
</code></pre>
    <br/>
    <br/>
    <li>Backquote Examples:</li>
    <br/>
<table>
    <thead>
        <tr>
            <th>Backquote Syntax</th>
            <th>Equivalent List-Building Code</th>
            <th>Result</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>`(a (+ 1 2) c)</code></td>
            <td><code>(list 'a '(+ 1 2) 'c)</code></td>
            <td><code>(a (+ 1 2) c)</code></td>
        </tr>
        <tr>
            <td><code>`(a ,(+ 1 2) c)</code></td>
            <td><code>(list 'a (+ 1 2) 'c)</code></td>
            <td><code>(a 3 c)</code></td>
        </tr>
        <tr>
            <td><code>`(a (list 1 2) c)</code></td>
            <td><code>(list 'a '(list 1 2) 'c)</code></td>
            <td><code>(a (list 1 2) c)</code></td>
        </tr>
        <tr>
            <td><code>`(a ,(list 1 2) c)</code></td>
            <td><code>(list 'a (list 1 2) 'c)</code></td>
            <td><code>(a (1 2) c)</code></td>
        </tr>
        <tr>
            <td><code>`(a ,@(list 1 2) c)</code></td>
            <td><code>(append (list 'a) (list 1 2) (list 'c))</code></td>
            <td><code>(a 1 2 c)</code></td>
        </tr>
    </tbody>
</table>
    <br/>
    <br/>
    <br/>
    <li>Syntax: <code>defmacro &lt;macro-name&gt; (&lt;lambda-list&gt; [&lt;doc-string&gt;] [&lt;decl&gt;]* &lt;form&gt;*)</code></li>
    <ul>
        <br/>
        <li><i>defmacro</i>: The defining keyword.</li>
        <br/>
        <li><i>macro-name</i>: The name of the macro (a symbol).</li>
        <br/>
        <li><i>lambda-list</i>:The parameter list, receives un-evaluates forms. Also supports &amp;optional, &amp;key like in the <b>DEFUN</b>.<br/>
            But in <b>DEFMACRO</b> &amp;rest is usually not used, instead &amp;body is represented as the body form.</li>
        <br/>
        <li><i>doc-string</i>: Optional. String shown by <b>DOCUMENTATION</b>.</li>
        <br/>
        <li><i>decl</i>: Compiler decalarations.</li>
        <br/>
        <li><i>form</i>: The body. Must return code (a Lisp form), not run the code.</li>
    </ul>
    <br/>
    <br/>
    <li>Example:</li>
<pre><code class="language-lisp line-numbers">(defmacro my-when (test &amp;body body)
  "If TEST is true, execute BODY like (progn ...)."
  `(if ,test
       (progn ,@body)))

(my-when (&gt; x 10)
  (print "positive")
  (incf x))

;; Macro expansion (what Lisp actually sees):
(if (&gt; x 0)
  (progn (print "positive") (incf x)))
</code></pre>
    <br/>
    <br/>
    <li>More advanced example(s):</li>
<pre><code class="language-lisp line-numbers">(defmacro echo-times (&amp;body body &amp;key (times 1) (prefix "=&gt; "))
  ;; Remove trailing keyword/value pairs from BODY so we only keep real forms.
  (let* ((rev (reverse body))
         (pure-rev
           (loop with lst = rev
                 ;; While the reversed list starts with a keyword/value pair,
                 ;; drop those two cells.
                 while (and (consp lst) (consp (cdr lst)) (keywordp (car lst)))
                 do (setf lst (cddr lst))
                 finally (return lst)))
         (pure-body (reverse pure-rev)))
    `(dotimes (i ,times)
       (format t "~A" ,prefix)
       (progn ,@pure-body))))

(echo-times
  (format t "Hello~%")
  (format t "World~%")
  :times 2
  :prefix "[*] ")


;; --------------------------


(defmacro with-prefix ((&amp;key (prefix "=&gt; ") (times 1)) &amp;body body)
  `(dotimes (i ,times)
     (format t "~A" ,prefix)
     (progn ,@body)))

(with-prefix (:prefix "[*] " :times 2)
  (format t "Hello~%")
  (format t "World~%"))
</code></pre>
    <br/>
    <br/>
    <li>The <i>declaration</i> part of <b>DEFMACRO</b>: Will be covered in the future...</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Variables</h3>
<ol>
    <li>Global variables are generally declared using the <code>DEFVAR</code> construct.</li>
<pre><code class="language-lisp line-numbers">; Define a global variable x with a value of `100`
(defvar x 100)
; Print the value of `x`
(print x)
</code></pre>
    <br/>
    <br/>
    <li>If there is no type declaration for variables in Lisp, you can directly specify a value for a symbol with the <code>SETQ</code> construct.</li>
    <br/>
    <br/>
    <li>There are two constructs: <code>LET</code> and <code>PROG</code> (no longer commonly used) for creating local variables.</li>
    <br/>
    <br/>
    <li>The <code>LET</code> construct has the following syntax.<br/>
        If you did NOT include an initial value for a variable, it is assigned <code>NIL</code>.</li>
<pre><code class="language-lisp line-numbers">(let ((var-1 val-1) (var-2 val-2) ... (var-n val-n))
  &lt;s-expression&gt;
  &lt;s-expression&gt;
  ...)
</code></pre>
    <br/>
    <br/>
    <li>The <code>PROG</code> construct has the following syntax.</li>
<pre><code class="language-lisp line-numbers">(prog (var-1 var-2 ... var-n)
  &lt;s-expression&gt;
  &lt;s-expression&gt;
  ...)
</code></pre>
    <br/>
    <br/>
    <li>Common Lisp supports <u>variable shadowing</u>.</li>
    <br/>
    <br/>
    <li>Common Lisp provides two ways to create global variables:
        <b>DEFVAR</b> and <b>DEFPARAMETER</b>.<br/>
        Both forms take a variable <i>name</i>, an initial <i>value</i>, and an <i>optional documentation string</i>.</li>
    <br/>
    <br/>
    <li>Global variables are conventionally named with names that start and end with <code>*</code> (e.g., <code>*db*</code>).</li>
<pre><code class="language-lisp line-numbers">(defvar *count* 0
  "Count of widgets made so far.")

(defparameter *gap-tolerance* 0.001
  "Tolerance to be allowed in widget gaps.")
</code></pre>
    <br/>
    <br/>
    <li><b>DEFCONSTANT</b> defines a named global constant.</li>
<pre><code class="language-lisp line-numbers">(sbcl) (defconstant +pi+ 3.1415926 "Approximation of PI")
(sbcl) +pi+
    3.1415926
</code></pre>
    <br/>
    <br/>
    <li><b>SETF</b> is the general-purpose <u>assignment operator</u> in Common Lisp.<br/>
        It is used to set or update the value of variables, places (like array elements, object fields, etc.), and more.<br/>
        <br/><code>(setf place value)</code></li>
    <br/>
    <br/>
    <li><b>SETF</b> can also assign to multiple places in sequence.</li>
<pre><code class="language-lisp line-numbers">(setf x 1)
(setf y 1)

(setf x 1 y 2)
</code></pre>
    <br/>
    <br/>
    <li><b>SETF</b> returns the newly assigned value,<br/>
        so you can also nest calls to <b>SETF</b> as in the following expression, which assigns both <i>x</i> and <i>y</i> the same random value: <code>(setf x (setf y (random 10)))</code></li>
    <br/>
    <br/>
    <li>You could increment / decrement a number with <b>SETF</b>:</li>
<pre><code class="language-lisp line-numbers">(setf x (+ x 1));   (incf x)
(setf x (+ x 10));  (incf x 10)
(setf x (- x 1));   (decf x)
</code></pre>
    <br/>
    <br/>
    <li><b>ROTATEF</b>: swaps values in-place by rotating them left-wise, returns <b>NIL</b>.<br/>
        <mark>NOTE</mark>: All places (variables, array elements, etc.) must be writable with <b>SETF</b>.</li>
<pre><code class="language-lisp line-numbers">(rotatef &lt;place1&gt; &lt;place2&gt; ... &lt;placeN&gt;)

place1 &lt;- place2
place2 &lt;- place3
...
placeN &lt;- original place1

(let ((a 1) (b 2) (c 3))
  (rotatef a b c)
  (list a b c))

(2 3 1)
</code></pre>
    <br/>
    <br/>
    <li><b>SHIFTF</b> shifts values left-wise and returns the original first value.</li>
<pre><code class="language-lisp line-numbers">(shiftf &lt;place1&gt; &lt;place2&gt; ... &lt;placeN&gt; &lt;new-value&gt;)

place1 &lt;- place2
place2 &lt;- place3
...
placeN &lt;- new-value
return &lt;- original place1

(let ((a 1) (b 2) (c 3))
  (shiftf a b c 100))       ;; returns 1
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Difference between <code>LET</code> and <code>LET*</code></h3>
<ol>
    <li><code>LET</code>: All variables are initialized in parallel.</li>
    <br/>
    <br/>
    <li><code>LET*</code>:
        Variables are initialized one by one in sequence,
        left to right, and each one can use the previous ones.</li>
<pre><code class="language-lisp line-numbers">(let* ((a 2)
       (b (+ a 3))      ; b = 2 + 3 = 5
       (c (* b 4)))     ; c = 5 * 4 = 20
  (list a b c))         ; (2 5 20)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Difference between <code>DEFVAR</code> and <code>DEFPARAMETER</code></h3>
<ol>
    <li><code>DEFVAR</code>: re-decl does not overwrite an existing value (can be later changed with assignment).</li>
<pre><code class="language-lisp line-numbers">(sbcl) (defvar *x* 10)
(sbcl) (defvar *x* 20)
(sbcl) *x*
    10
</code></pre>
    <br/>
    <br/>
    <li><code>DEFPARAMETER</code>: re-decl always resets the value.</li>
<pre><code class="language-lisp line-numbers">(sbcl) (defparameter *x* 10)
(sbcl) (defparameter *x* 20)
(sbcl) *x*
    20
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Escape Character</h3>
<ol>
    <li>A backslash ( <code>\</code> ) escapes the next character, causing it to be included in the string regardless of what it is.</li>
<pre><code class="language-lisp line-numbers">"foo"       ; foo
"f\oo"      ; foo,  because `\o` escapes `o`, treating it iterally like the character `o`.
"fo\\o"     ; fo\o
"fo\'o"     ; fo'o
"fo\"o"     ; fo"o
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Symbol</h3>
<ol>
    <li>There are 10 characters that serve other syntactic purposes can NOT appear in names:</li>
    <br/>
    <ul>
        <li>Open Parentheses (<code> ( </code>)</li>
        <br/>
        <li>Close Parentheses (<code> ) </code>)</li>
        <br/>
        <li>Double Quote (<code> " </code>)</li>
        <br/>
        <li>Single Quote (<code> ' </code>)</li>
        <br/>
        <li>Backtick (<code> ` </code>)</li>
        <br/>
        <li>Comma (<code> , </code>)</li>
        <br/>
        <li>Colon (<code> : </code>)</li>
        <br/>
        <li>Semicolon (<code> ; </code>)</li>
        <br/>
        <li>Backslash (<code> \ </code>)</li>
        <br/>
        <li>Vertical Bar (<code> | </code>)</li>
        <br/>
    </ul>
    <br/>
    <li>If you really want to use those character,
        try to escape them with a backslash (<code> \ </code>)<br/>
        or surround the part of the name containing characters that need escaping
        with vertical bars (<code> | </code>).</li>
<pre><code class="language-lisp line-numbers">
    (defun test\,-lisp ()
      (write-line "Hello, world!"))
    (test\,-lisp)

    (defun |test,-lisp| ()
      (write-line "Hello, world!"))
    (|test,-lisp|)

    (defun | test,-lisp | ()
      (write-line "Hello, world!"))
    (| test,-lisp |)
</code></pre>
    <br/>
    <br/>
    <li><mark>NOTE</mark>:
        The symbol names are <u>case-insensitive</u>,
        it converts all unescaped characters to upper case,
        like <i>foo</i>, <i>Foo</i>, and <i>FOO</i> are the same.<br/>
        However, the f\o\o and |foo| will preserve the case, they are read as <i>foo</i>.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Keyword Symbols</h3>
<ol>
    <li>Keyword symbols are prefixed with a colon (e.g., <code>:name</code>, <code>:id</code>).<br/><br/>
        This prefix automatically makes them part of the <b>KEYWORD</b> package.</li>
    <br/>
    <br/>
    <li>Unlike regular symbols, keyword symbols <u>evaluate to themselves</u>.</li>
<pre><code class="language-lisp line-numbers">&gt; :example
:EXAMPLE

&gt; :EXample
:EXAMPLE

&gt; :\example
:|eXAMPLE|

&gt; :a\,b
:|A,B|

&gt; :123
:|123|

&gt; :123abc
:123ABC

&gt; :abc123
:ABC123

&gt; :|xyz|
:|xyz|
</code></pre>
    <br/>
    <br/>
    <li>Keyword symbols are often used as keys in property list.</li>
<pre><code class="language-lisp line-numbers">&gt; (setq person '(:name "Alice" :age 20))
&gt; (getf person :name)
"Alice"
; Btw, (setq person (:name "Alice" :age 20)) is invalid, because Lisp will tru to eval as if :name were a function.
; You can also use (setq person (list :name "Alice" :age 20)) instead.
</code></pre>
    <br/>
    <br/>
    <li>Many libraries use keyword symbols for configuration settings.</li>
<pre><code class="language-lisp line-numbers">(open "settings.conf", :direction :output)</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3><u>if</u> Statement</h3>
<ol>
    <li>Syntax:<code> (if &lt;cond&gt; &lt;then&gt; [&lt;else&gt;]) </code></li>
    <br/>
    <ul>
        <li><i>cond</i> is a condition that eval to either NIL (false) or non-NIL (true).</li>
        <br/>
        <li><i>then</i> is the expression to exec if <i>cond</i> is true.</li>
        <br/>
        <li><i>else</i> is the optional expression to exec if <i>cond</i> is false.</li>
        <br/>
    </ul>
    <br/>
    <br/>
    <li>Basic Example:</li>
<pre><code class="language-lisp line-numbers">(if (&gt; 10 5)
  (write-line "10 &gt; 5")
  (write-line "10 &lt;= 5"))
</code></pre>
    <br/>
    <li>Without <i>else</i> expression:</li>
<pre><code class="language-lisp line-numbers">(if (= 1 1) (write-line "1 equals 1"))</code></pre>
    <br/>
    <br/>
    <li>Nested <i>if</i>: </li>
<pre><code class="language-lisp line-numbers">(if (&gt; 10 5)
  (if (&lt; 3 4)
    (write-line "10 &gt; 5 and 3 &lt; 4")
    (write-line "10 &gt; 5 and 3 &gt;= 4"))
  (write-line "10 &lt;= 5"))
</code></pre>
    <br/>
    <br/>
    <li>The <i>if</i> expression returns the result of the evaluated <i>then</i> or <i>else</i> form.</li>
<pre><code class="language-lisp line-numbers">(let ((x 10))
  (if (&gt; x 5) (+ x 10) (- x 10)))
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about <u>quote</u></h3>
<ol>
    <li>It is used to prevent an expression from being evaluated.</li>
    <br/>
    <br/>
    <li>Syntax:
        <code>(quote &lt;expr&gt;)</code> or shorthandly <code>'&lt;expr&gt;</code></li>
    <br/>
    <br/>
    <li>Example Usage:</li>
<pre><code class="language-lisp line-numbers">&gt; (quote (+ 1 2))
(+ 1 2)
&gt; '(+ 1 2)
(+ 1 2)
&gt; (+ 1 2)
3

&gt; 'a
A
&gt; '\a
|a|


&gt; (setq a 100)
100
&gt; a
100
&gt; 'a
A
&gt; (symbol-value 'a)
100


&gt; (setq a 'b)   ; a holds the symbol B
B
&gt; (set a 100)   ; same as (set 'b 100)
100
&gt; b
100
</code></pre>
    <br/>
    <br/>
    <li><code>(setq a 100)</code> and <code>(setq 'a 100)</code> are NOT the same
        (<b>SETQ</b> expects an unquoted symbol in the variable position).</li>
    <br/>
    <br/>
    <li>
        If you want to assign to a variable by a symbol at runtime, use the symbol's value cell:
        <code>(setf (symbol-value 'a) 100)</code> or <code>(set 'a 100)</code>
    </li>
    <br/>
    <br/>
    <li><code>'a</code> is a symbol ONLY when evaluated, normally it is treated as an quoted expression <code>(quote A)</code>.</li>
    <br/>
    <br/>
    <li>Quick contrasts:</li>
    <ul>
        <br/>
        <li><code>(setq a 100)</code>: special operator; does NOT evaluate the variable name; sets the variable <code>A</code>.</li>
        <br/>
        <li><code>(setf a 100)</code>: for simple variables same as <b>SETQ</b>.</li>
        <br/>
        <li><code>(set 'a 100)</code>: function; evaluates <code>'a</code> to <code>A</code>; sets <code>A</code>'s global/special value cell.</li>
        <br/>
        <li><code>(set a 100)</code>: function; evaluates <code>a</code> (must be a symbol); sets that symbol's global/special value.</li>
    </ul>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>True, False and Equality</h3>
<ol>
    <li>The symbol <b>t</b> or <b>T</b> is conventionally treated as true in Common Lisp.<br/><br/>
        <code>(if t "True" "False")</code><code class="hl-grey-fg"> ; returns "True"</code></li>
    <br/>
    <br/>
    <li>The expressions <b>nil</b>, <b>'nil</b>, <b>()</b> and <b>'()</b> are considered false in Common Lisp.<br/><br/>
        <code>(if nil "T" "F")</code><code class="hl-grey-fg"> ; returns "F"</code><br/>
        <code>(if () "T" "F")</code><code class="hl-grey-fg"> ; returns "F"</code><br/>
    </li>
    <br/>
    <br/>
    <li><b>EQ</b> checks whether two values are literally the same object: the same address, same identity.</li>
<pre><code class="language-lisp line-numbers">(eq 1000 1000)   ;; might be NIL on some Lisps
(eq 'foo 'foo)   ;; always T (same interned symbol)
</code></pre>
    <br/>
    <br/>
    <li><b>EQL</b> is just like <b>EQ</b>, but slightly stronger: it also considers numbers and characters with the same value as equal.</li>
<pre><code class="language-lisp line-numbers">(eql 1000 1000)  ;; always T
(eql 1.0 1)      ;; NIL (different types)
(eql #\A #\A)    ;; T
</code></pre>
    <br/>
    <br/>
    <li><b>EQUAL</b> compares structural lists and strings (and bit-vectors).</li>
<pre><code class="language-lisp line-numbers">(equal '(a (b)) '(a (b)))   ;; T
(equal "Foo" "Foo")         ;; T
(equal "Foo" "foo")         ;; NIL (case-sensitive)
(equal 1 1.0)               ;; NIL (numbers must be EQL)
(equal #\A #\a)             ;; NIL
</code></pre>
    <br/>
    <br/>
    <li><b>EQUALP</b> is more forgiving: case-insensitive for strings and characters, and value comparison for numbers.</li>
<pre><code class="language-lisp line-numbers">(equalp "Foo" "foo")        ;; T
(equalp #\A #\a)            ;; T
(equalp 1 1.0)              ;; T
(equalp '(1 "A") #(1 "a"))  ;; T (list vs vector ok; string case ignored)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about <u>cond</u></h3>
<ol>
    <li><b>cond</b> is a versatile conditional construcy used for multi-branch descision-making.
        It is preferred over nested <b>if</b>.</li>
    <br/>
    <br/>
    <li>Syntax:</li>
<pre><code class="language-lisp line-numbers">(cond
  (&lt;cond-1&gt; &lt;form-1-1&gt; &lt;form-1-2&gt; ...)
  (&lt;cond-2&gt; &lt;form-2-1&gt; &lt;form-2-2&gt; ...)
  ...
  (t &lt;default-form-1&gt; &lt;default-form-2&gt; ...))
</code></pre>
    <ul>
        <br/>
        <li><b><i>cond-n</i></b> is a condition</li>
        <br/>
        <li><b><i>form</i></b> is one or more expressions to be executed if <b><i>cond-n</i></b> is true.</li>
        <br/>
        <li><b><i>t</i></b> in the end act as a default case.</li>
        <br/>
        <li><mark>NOTE</mark>: only the first <b><i>cond</i></b> which is eval-ed to true is exec-ed.</li>
    </ul>
    <br/>
    <br/>
    <li>Example Usage:</li>
<pre><code class="language-lisp line-numbers">(defun categorize-number (x)
  (cond
    ((&lt; x 0) "negative")
    ((&gt; x 0) "positive")
    ((= x 0) "zero")))

(categorize-number 10)
(categorize-number -7)
(categorize-number 0)

(defun analyze-number (x)
  (cond
    ((&lt; x 0) (format t "~a &lt; 0~%" x) "negative")
    ((&gt; x 0) (format t "~a &gt; 0~%" x) "positive")
    ((= x 0) (format t "x = 0~%") "zero")))

(analyze-number -3)
; it will "-3 &lt; 0" and return "negative"
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Basics about Functions</h3>
<ol>
    <li>Normally functions are defined using the <b>DEFUN</b> macro.<br/>
        The basic skeleton of a <b>DEFUN</b> looks like this:</li>
<pre><code class="language-lisp line-numbers">(defun &lt;function-name&gt; (&lt;param-list&gt;)
  "Optional documentation string."
  &lt;function-body&gt;)
</code></pre>
    <br/>
    <br/>
    <li><i>frob-widget</i> is better Lisp style than either <i>frob_widget</i> or <i>frobWidget</i>.</li>
    <br/>
    <br/>
    <li>If the function takes no arguments, the list is empty, written as <code>()</code>.<br/>
        Different flavors of parameters handle <u>required</u>, <u>optional</u>, <u>rest</u>, and <u>keyword</u> arguments.
    </li>
    <br/>
    <br/>
    <li>If a string literal follows the parameter list,
        it's a documentation string that should describe the purpose of the function.<br/>
        When the function is defined, the documentation string will be associated with the name of the function and can later be obtained using the <b>DOCUMENTATION</b> function.</li>
    <br/>
    <br/>
    <li>Example of a function:</li>
<pre><code class="language-lisp line-numbers">(defun verbose-sum (x y)
  "Sum any two numbers after printing a message."
  (format t "Summing ~d and ~d.~%" x y)
  (+ x y))
</code></pre>
    <br/>
    <br/>
    <li>
        When a parameter list is a simple list of variable names, as in <code>verbose-sum</code>, the parameters are called <u>required parameters</u>.<br/>
        If a function is called with too few or too many arguments, Lisp will signal an error.</li>
    <br/>
    <br/>
    <li>
        To define a function with <u>optional parameters</u>,<br/>
        after the names of any <u>required parameters</u>,
        place the symbol <b>&amp;optional</b> followed by the name(s) of the <u>optional parameters</u>.
    </li>
<pre><code class="language-lisp line-numbers">(defun foo (a b &amp;optional c d)
  (list a b c d))

(foo 1 2);      (1 2 NIL NIL)
(foo 1 2 3);    (1 2 3 NIL)
(foo 1 2 3 4);  (1 2 3 4)



(defun foo (a &amp;optional (b 10) (c 20))
  (list a b c))
(foo 1);        (1 10 20)
(foo 1 2);      (1 2 20)
(foo 1 2 3);    (1 2 3)



;; This would cause the height parameter to take the same value as the width parameter unless explicitly specified.
(defun make-rectangle (width &amp;optional (height width))
  ...)
</code></pre>
    <br/>
    <br/>
    <li>Occasionally,
        it's useful to know whether the value of an optional argument was supplied by the caller or is the default value.<br/>
        By convention, these variables are usually named the same as the actual parameter with a <code>"-supplied-p"</code> suffix.</li>
<pre><code class="language-lisp line-numbers">(defun foo (a b &amp;optional (c 3 c-supplied-p))
  (list a b c c-supplied-p))

(foo 1 2);      (1 2 3 NIL)
(foo 1 2 3);    (1 2 3 T)
</code></pre>
    <br/>
    <br/>
    <li>Lisp lets you include a catchall parameter after the symbol <b>&amp;rest</b>.<br/>
        It should be placed after the <u>required parameter(s)</u> and <u>optional parameter(s)</u>.
    </li>
<pre><code class="language-lisp line-numbers">(defun sum (&amp;rest nums)
  (reduce #'+ nums :initial-value 0))

(sum);              0
(sum 1 2 3 4);      10
</code></pre>
    <br/>
    <br/>
    <li>To give a function keyword parameters, after any <u>required</u>, <u>optional</u>, and <u>rest</u> parameters,<br/>
        you include the symbol <b>&amp;key</b> and then any number of keyword parameter specifiers.</li>
<pre><code class="language-lisp line-numbers">(defun foo (&amp;key a b c)
  (list a b c))

(foo)                ; (NIL NIL NIL)
(foo :a 1)           ; (1 NIL NIL)
(foo :b 2)           ; (NIL 2 NIL)
(foo :c 3)           ; (NIL NIL 3)
(foo :a 1 :c 3)      ; (1 NIL 3)
(foo :a 1 :b 2 :c 3) ; (1 2 3)
(foo :a 1 :c 3 :b 2) ; (1 2 3)



(defun foo (&amp;key (a 0) (b 0 b-supplied-p) (c (+ a b)))
  (list a b c b-supplied-p))

(foo)                ; (0 0 0 NIL)
(foo :a 1)           ; (1 0 1 NIL)
(foo :b 1)           ; (0 1 1 T)
(foo :b 1 :c 4)      ; (0 1 4 T)
(foo :a 2 :b 1 :c 4) ; (2 1 4 T)
</code></pre>
    <br/>
    <br/>
    <li>Also, you can have keyword alias (it must be in a list):</li>
<pre><code class="language-lisp line-numbers">(defun foo (&amp;key ((:apple a)) ((:banana b) 0) ((:cherry c) 0 c-supplied-p))
  (list a b c c-supplied-p))

(foo :apple 10 :banana 20 :cherry 30); (10 20 30 T)



(defun foo (&amp;rest rest &amp;key a b c)
  (list rest a b c))

(foo :a 1 :b 2 :c 3); ((:A 1 :B 2 :C 3) 1 2 3)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Function Return Values</h3>
<ol>
    <li><b>RETURN-FROM</b> is actually not tied to functions at all.
        It is used to return from a block of code defined with the <b>BLOCK</b> special operator.<br/>
    <br/>
    <br/>
    <li>
        However, <b>DEFUN</b> automatically wraps the whole function body in a block with the same name as the function.<br/>
        So, evaluating a <b>RETURN-FROM</b> with the <u>name of the function</u> and the <u>value</u> you want to return will cause the function to immediately exit with that value.</li>
    </li>
<pre><code class="language-lisp line-numbers">(defun first-positive (xs)
  (dolist (x xs)
    (when (plusp x)
      (return-from first-positive x)))
  nil)

(first-positive '(-3 -2 0 4 -1)); 4
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Functions As Data, a.k.a. Higher-Order Functions</h3>
<ol>
    <li>The special operator <b>FUNCTION</b> provides the mechanism for getting at a function object.<br/>
        It takes a single argument and returns the function with that name. The syntax <b>#'</b>, is a syntactic sugar for <b>FUNCTION</b></li>
<pre><code class="language-lisp line-numbers">(sbcl) (defun foo (x) (* 2 x))
FOO
(sbcl) (function foo)
#<Interpreted Function FOO>
(sbcl) #'foo
#<Interpreted Function FOO>
</code></pre>
    <br/>
    <br/>
    <li><b>FUNCALL</b> is the one to use when you know the number of arguments you're going to pass to the function at the time you write the code.<br/>
        <br/><code>(foo 1 2 3)</code> and <code>(funcall #'foo 1 2 3)</code> are basically the same.</li>
    <br/>
    <br/>
    <br/>
    <li>The following function demonstrates a more apt use of <b>FUNCALL</b>.<br/>
        It accepts a function object as an argument and plots a simple ASCII-art histogram of the values returned by the argument function when it's invoked on the values from <code>min</code> to <code>max</code>, stepping by <code>step</code>.</li>
<pre><code class="language-lisp line-numbers">(defun plot (fn min max step)
  (loop for i from min to max by step do
    (loop repeat (funcall fn i) do (format t "*"))
    (format t "~%")))

(plot #'exp 0 4 1/2)
*
*
**
****
*******
************
********************
*********************************
******************************************************
NIL
</code></pre>
    <br/>
    <br/>
    <li><b>APPLY</b> calls a function with arguments, where the last argument to apply must be a <u>list of remaining arguments</u> (empty list <code>()</code> / <code>'()</code> / <code>NIL</code> is also ok).<br/><br/>
        <code>(apply &lt;function&gt; &lt;arg1&gt; &lt;arg2&gt; ... &lt;last-arg-list&gt;)</code></li>
    <br/>
    <br/>
    <br/>
    <li>Example with <b>APPLY</b>:
        <code>(apply #'+ 1 2 '(3 4 5))</code> is equal to <code>(+ 1 2 3 4 5)</code>, which returns 15.
    </li>
    <br/>
    <br/>
    <br/>
    <li><b>REDUCE</b> repeatedly applies a function pairwise to the elements of a list to "combine" them into a single result.<br/><br/>
        <code>(reduce &lt;function&gt; &lt;sequence&gt; &amp;key :initial-value :from-end)</code><br/><br/>
        Therefore, <code>(reduce f '(a b c d))</code> is equivalent to <code>(f (f (f a b) c) d)</code></li>
    <br/>
    <br/>
    <br/>
    <li>Example with <b>REDUCE</b>:
        <code>(reduce #'+ '(1 2 3 4) :initial-value 0)</code>
        is equivalent to <code>(+ (+ (+ (+ 0 1) 2) 3) 4)</code>, which returns 10.</li>
    <br/>
    <br/>
    <br/>
    <li>Anonymous functions are created with <code>(lambda (args...) body...)</code>.<br/>
        They produce a function object (often called a <i>closure</i> when it captures variables).<br/>
        To pass/call them, use a function designator: <code>#'(lambda ...)</code>.</li>
<pre><code class="language-lisp line-numbers">(funcall #'(lambda (x y) (+ x y)) 3 4)
;; 7




(apply #'(lambda (&amp;rest xs) (reduce #'+ xs :initial-value 0)) '(1 2 3))
;; 6




(defun make-counter (&amp;optional (start 0))
  (let ((n start))
    #'(lambda () (incf n))))

(let ((next (make-counter 10)))
  (list (funcall next) (funcall next) (funcall next)))

;; Example of closure: (11 12 13)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>The difference between (3 4 5) and '(3 4 5)</h3>
<ol>
    <li><code>(3 4 5)</code> is a function call.<br/><br/>
        In Lisp, anything inside parentheses is treated as a function call unless you explicitly prevent evaluation.</li>
    <br/>
    <br/>
    <br/>
    <li><code>'(3 4 5)</code> is a quoted list — a literal value.<br/><br/>
        The single quote ( <code>'</code> ) is shorthand for </code>(quote ...)</code>.</li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>'(a b c) VS (list a b c)</h3>
<ol>
    <li>They are NOT the same thing!</li>
    <br/>
    <br/>
    <li><code>'(...)</code> is a quoted list (no evaluation).</li>
    <br/>
    <br/>
    <li><code>(list a b c)</code> calls the function list, after evaluating of each argument.</li>
    <br/>
    <br/>
    <li>Comparison with a real-life example:</li>
<pre><code class="language-lisp line-numbers">(setq a 10 b 20 c 30)
(list a b c)            ;; (10 20 30)
'(a b c)                ;; (A B C)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>PROGN</h3>
<ol>
    <li><b>PROGN</b> is a special operator in Common Lisp that evaluates multiple expressions in sequence and returns the value of the last one.</li>
    <br/>
    <br/>
    <li>Syntax: <code>(progn &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprN&gt;)</code></li>
    <br/>
    <br/>
    <li>Example:</li>
<pre><code class="language-lisp line-numbers">(progn
  (format t "Step 1~%")
  (format t "Step 2~%")
  (+ 2 3))   ;; last expression

;; Output:
;; Step 1
;; Step 2
;; 5
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>WHEN</h3>
<ol>
    <li><b>WHEN</b> is like a simplified IF that only has a then branch (no else).<br/>
        If the condition is true, it executes one or more expressions.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(let ((x 5))
  (when (&gt; x 0)
    (format t "x is positive~%")
    (* x 2)))
;; prints "x is positive"
;; returns 10
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>UNLESS</h3>
<ol>
    <li><b>UNLESS</b> is the logical opposite of <b>WHEN</b>. If the condition is false (<code>NIL</code>), it executes the body.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(let ((x 0))
  (unless (&gt; x 0)
    (format t "x is not positive~%")
    "Did something"))
;; prints "x is not positive"
;; returns "Did something"
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>AND, OR, and NOT</h3>
<ol>
    <li><b>AND</b> evaluates the arguments from left to right. <code>(and &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprN&gt;)</code><br/>
        It returns:</li>
    <ul>
        <br/>
        <li>The first falsy (<code>NIL</code>) value it encounters.</li>
        <br/>
        <li>Or the last value if all are true.</li>
    </ul>
    <br/>
    <br/>
    <li><b>OR</b> evaluates the arguments from left to right. <code>(or &lt;expr1&gt; &lt;expr2&gt; ... &lt;exprN&gt;)</code><br/>
        It returns:</li>
    <ul>
        <br/>
        <li>The first non-falsy (non-<code>NIL</code>) value it encounters.</li>
        <br/>
        <li>Or <code>NIL</code> if all are false.</li>

    </ul>
    <br/>
    <br/>
    <li><b>NOT</b> returns <code>T</code> if the argument is <code>NIL</code>, and <code>NIL</code> otherwise.</li>
    <br/>
    <br/>
    <li>Examples:</li>
<pre><code class="language-lisp line-numbers">(and t 42 "hello")      ;; "hello"
(and t nil "oops")      ;; NIL
(and)                   ;; T

(or nil 0 "yes")        ;; 0
(or nil nil nil)        ;; NIL
(or)                    ;; NIL

(not nil)               ;; T
(not t)                 ;; NIL
(not 42)                ;; NIL (42 is truthy)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>DOLIST and DOTIMES</h3>
<ol>
    <li><b>DOLIST</b> iterates over each element in a list, binding it to a variable for each iteration.<br/>
        Syntax: <code>(dolist (&lt;variable&gt; &lt;list&gt; &amp;optional &lt;return-value&gt;) &lt;body&gt;)</code></li>
    <ul>
        <br/>
        <li><i>variable</i>: The loop variable that it takes on each element of <i>list</i>.</li>
        <br/>
        <li><i>list</i>: The list to iterate over.</li>
        <br/>
        <li><i>body</i>: Evaluation for each iteration.</li>
        <br/>
        <li><i>return-value</i>: Expression evaluated and returned after the loop finishes.</li>
    </ul>
    <br/>
<pre><code class="language-lisp line-numbers">(dolist (x '(a b c))
  (format t "Element: ~A~%" x))
;; Element: A
;; Element: B
;; Element: C


(dolist (x '(1 2 3) "Done")
  (print x))
;; Returns "Done" after printing the numbers.
</code></pre>
    <br/>
    <br/>
    <li><b>DOTIMES</b> iterates over a fixed number of times.<br/>
        Syntax: <code>(dotimes (&lt;variable&gt; &lt;N&gt; &amp;optional &lt;return-value&gt;) &lt;body&gt;)</code></li>
    <br/>
    <ul>
        <li>The loop counter starts at <i>0</i> and ends at <i>N-1</i>, exactly <i>N</i> iterations.</li>
        <br/>
    </ul>
<pre><code class="language-lisp line-numbers">(dotimes (i 5)
  (format t "i = ~A~%" i))
;; i = 0
;; i = 1
;; i = 2
;; i = 3
;; i = 4


(dotimes (i 3 "Loop done")
  (print i))
;; i = 0
;; i = 1
;; i = 2
;; "Loop done"
</code></pre>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>DO</h3>
<ol>
    <li><b>DO</b> is a low-level, general-purpose looping construct in Common Lisp.</li>
    <br/>
    <br/>
    <li>Syntax:</li>
<pre><code class="language-lisp line-numbers">(do ((&lt;var1&gt; &lt;init1&gt; [&lt;step1&gt;])
     (&lt;var2&gt; &lt;init2&gt; [&lt;step2&gt;])
     ...
     (&lt;varN&gt; &lt;initN&gt; [&lt;stepN&gt;]))
    (&lt;end-test&gt; [&lt;result-form&gt;])
  &lt;body&gt;)
</code></pre>
<ul>
    <br/>
    <li><i>var</i>: iter variable.</li>
    <br/>
    <li><i>init</i>: initial value (evaluated once at start).</li>
    <br/>
    <li><i>step</i>: optional. Controls how to update the variable (evaluated after each iteration).</li>
    <br/>
    <li><i>end-test</i>: checked before each iteration.<br/>
        If true, loop exists and evaluates <i>return-from</i>;<br/>
        if false, executes the loop body.</li>
    <br/>
    <li><i>return-from</i>: optional. If omitted, the loop returns <code>NIL</code>.</li>
</ul>
    <br/>
    <br/>
    <li>Basic Example:</li>
<pre><code class="language-lisp line-numbers">(do ((i 0 (+ i 1)))
    ((&gt;= i 5) 'done)
  (format t "i = ~A~%" i))

;; i = 0
;; i = 1
;; i = 2
;; i = 3
;; i = 4
;; DONE



(do ((i 0 (+ i 1))
     (j 10 (- j 2)))
    ((&gt; i 3) (list i j))
  (format t "i=~A, j=~A~%" i j))

;; i=0, j=10
;; i=1, j=8
;; i=2, j=6
;; i=3, j=4
;; (4 2)



(do ((x 5))         ; x stays 5 forever — infinite loop!
    ((<= x 0))
  (print x))
</code></pre>
    <br/>
    <br/>
    <li>Early exit using <b>RETURN</b>:</li>
<pre><code class="language-lisp line-numbers">(do ((i 0 (+ i 1)))
    (nil)           ; end test is NIL, infinite loop unless broken
  (when (= i 3) (return 'early))
  (print i))

;; 0
;; 1
;; 2
;; EARLY
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>LOOP</h3>
<ol>
    <li><b>LOOP</b> is a <u>macro</u> in Common Lisp that provides a declarative, English-like syntax for performing iterations and collecting results.</li>
    <br/>
    <br/>
    <li>Basic syntax: <code>(loop [&lt;loop-clauses&gt;])</code></li>
    <br/>
    <br/>
    <li>A loop is composed of clauses like:</li>
    <ul>
        <br/>
        <li>Iteration: <code>for</code>, <code>from</code>, <code>to</code>, <code>downto</code>, <code>below</code>, <code>above</code>, <code>by</code></li>
        <br/>
        <li>List / Vectors: <code>in</code>, <code>on</code>, <code>across</code></li>
        <br/>
        <li>Conditions: <code>when</code>, <code>unless</code>, <code>if</code>, <code>else</code>, <code>end</code></li>
        <br/>
        <li>Accumulators: <code>collect</code>, <code>append</code>, <code>sum</code>, <code>count</code>, <code>maximize</code>, <code>minimize</code></li>
        <br/>
        <li>Size effects: <code>do</code>, <code>finally</code>, <code>return</code></li>
        <br/>
        <li>Control: <code>while</code>, <code>until</code>, <code>repeat</code>, <code>named</code>, <code>initially</code></li>
    </ul>
    <br/>
    <br/>
    <li><mark>NOTE</mark>: <b>LOOP</b> syntax is non-Lispy — it doesn't follow S-expression style.</li>
    <br/>
    <br/>
    <li>Examples:</li>
    <br/>
<pre><code class="language-lisp line-numbers">(loop for x in '(a b c ) do
  (print x))
;; A
;; B
;; C

(loop as i from 1 to 3 do (print i))
;; 1
;; 2
;; 3

(loop for i from 1 to 3 do (print i))           ;; 1 2 3
(loop for i from 3 downto 1 do (print i))       ;; 3 2 1
(loop for i from 1 upto 3 do (print i))         ;; 1 2 3
(loop for i from 1 below 4 do (print i))        ;; 1 2 3
(loop for i from 5 above 2 do (print i))        ;; 5 4 3
(loop for i from 0 to 10 by 2 do (print i))     ;; 0 2 4 6 8 10

(loop repeat 3 do
  (print "Hello"))
;; "Hello"
;; "Hello"
;; "Hello"

(loop named my-loop
  for i from 1 to 10 do
    (when (= i 5) (return-from my-loop 'stopped)))
;; 'STOPPED

(loop
  initially (format t "Start~%")
  for i from 1 to 2 do (print i))

(loop
  for i from 1 to 2 do (print i)
  finally (format t "Done~%"))

(loop for x in '(a b c) collect x)                  ;; (A B C)
(loop for tail on '(1 2 3) collect tail)            ;; ((1 2 3) (2 3) (3))
(loop for x across #(10 20 30) collect (* x 2))     ;; (20 40 60)

(loop
  for i from 1 to 3
    if (evenp i)
      collect i
    else
      collect (- i)
    end)
;; (-1 2 -3)

(loop for i from 1 to 3 collect (* i i))            ;; (1 4 9)
(loop for x in '((a b) (c) (d e)) append x)         ;; (A B C D E)
(loop for i from 1 to 5 sum i)                      ;; 15
(loop for i in '(1 2 3 4 5) count (evenp i))        ;; 2
(loop for x in '(3 7 2 9 5) maximize x)             ;; 9
(loop for x in '(3 7 2 9 5) minimize x)             ;; 2
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Quote vs. Backquote</h3>
<ol>
    <li>Quote (<code>'</code> or <code>(quote ...)</code>): Don't evaluate, take it as data (prevents the usual evaluation of lists/symbols.).</li>
    <br/>
<pre><code class="language-lisp line-numbers">'foo            ;; FOO            ; a symbol, not the value of variable FOO
(quote foo)     ;; same as above

'(1 2 3)        ;; (1 2 3)        ; a literal list (don't evaluate it)
'(+ 1 2)        ;; (+ 1 2)        ; code-as-data, not 3
</code></pre>
    <br/>
    <li>Backquote / Quasiquote (<code>`</code> or <code>(quasiquote ...)</code>): Make a template, selectively evaluate with commas.</li>
    <ul>
        <br/>
        <li><code>,expr</code> (unquote): evaluates expr and inserts the result.</li>
        <br/>
        <li><code>,@expr</code> (unquote-splicing): evaluates expr and splices its elements into the surrounding list.</li>
    </ul>
<pre><code class="language-lisp line-numbers">(let ((a 10) (b '(x y)))
  `(+ ,a 20)                ;; (+ 10 20)    NOTE: it evals a template to a list (not 30 that no further evaluation by far!).
  `(1 2 ,a ,@b 99))         ;; (1 2 10 X Y 99)

(let ((xs '(a b)))
  `(x ,xs y))   ;;  (X (A B) Y)
  `(x ,@xs y))  ;;  (X A B Y)
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Destructing Parameter in DEFMACRO</h3>
<ol>
    <li>When you define a macro, you tell Lisp how to map the call form into symbols that you can use inside the macro body.</li>
<pre><code class="language-lisp line-numbers">(defmacro simple (x y)
  `(list ,x ,y))

(simple 10 20)
;; expands to (LIST 10 20) and will be evaluated when using it.
</code></pre>
    <br/>
    <br/>
    <li>In a <b>DEFMACRO</b>,
        your lambda list doesn't just bind symbols to arguments — it can pattern-match the entire shape of the call form.</li>
<pre><code class="language-lisp line-numbers">(defmacro swap! ((a b))
  `(let ((temp ,a))
     (setf ,a ,b
           ,b temp)))

(swap! (x y))
;; expands to:
;; (LET ((TEMP X)) (SETF X Y Y TEMP))



(defmacro let1 ((var val) &amp;body body)
  `(let ((,var ,val))
     ,@body))

(let1 (x (+ 1 2))
  (print x))
;; expands to (LET ((X (+ 1 2))) (PRINT X))



(defmacro bind2 ((a &amp;optional (b 10)) &amp;body body)
  `(let ((,a ,b))
     ,@body))

(bind2 (x 5) (print x)) ;; (LET ((X 5)) (PRINT X))
(bind2 (x) (print x))   ;; (LET ((X 10)) (PRINT X))



(defmacro with-options ((&amp;key (a 1) (b 2)) &amp;body body)
  `(let ((x ,a) (y ,b))
     ,@body))

(with-options (:a 10)
  (print (+ x y)))
;; expands to:
;; (LET ((X 10) (Y 2)) (PRINT (+ X Y)))
</code></pre>
    <br/>
    <br/>
    <li>All in all, what I understood it, in the language I could understand, is that:<br/>
        normally because <code>&amp;body</code> acts like <code>&amp;rest</code>,
        so this caused the <i>body</i> would very frequently also include the leter key parameters if given,<br/>
        using this pattern-matching, we can promote the key parameters before the body,
        so it very much eases our work to remove the key parameters from the macro call.
    </li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Collections</h3>
<ol>
    <li>Vectors are Common Lisp's basic integer-indexed collection, and they come in two flavors: fixed-size vectors and resizable vectors.</li>
    <br/>
    <br/>
    <li>Simplest way to construct a fixed-size vector with existing elements,
        is to use either <code>(vector [&lt;elements&gt;])</code> or <code>#(&lt;elements&gt;)</code> syntax:</li>
<pre><code class="language-lisp line-numbers">(vector)
#()

(vector 1)
#(1)

(vector 1 2)
#(1 2)
</code></pre>
    <br/>
    <br/>
    <li><b>MAKE-ARRAY</b> is much more vesatile;</li>
<pre><code class="language-lisp line-numbers">(make-array 5 :initial-element nil);    #(NIL NIL NIL NIL NIL)



;; `fill-pointer` stores the number of elements inside the vector.
(make-array 5 :fill-pointer 0);         #()



(defparameter *x* (make-array 5 :fill-pointer 0))

(vector-push 'a *x*);                   0
*x*                 ;					#(A)
(vector-push 'b *x*);					1
*x*                 ;					#(A B)
(vector-push 'c *x*);					2
*x*                 ;					#(A B C)
(vector-pop *x*)    ;					C
*x*                 ;					#(A B)
(vector-pop *x*)    ;					B
*x*                 ;					#(A)
(vector-pop *x*)    ;					A
*x*                 ;					#()



;; To make an arbitrarily resizable vector, you need to pass MAKE-ARRAY another keyword argument: `:adjustable`.
(make-array 5 :fill-pointer 0 :adjustable t); #()



;; You can also specify that a vector only contains certain types of elements (if non-specified, then it could take different kinds of elements).
(make-array 5 :fill-pointer 0 :adjustable t :element-type 'character)
</code></pre>
    <br/>
    <br/>
    <li>Vector as sequence:</li>
<pre><code class="language-lisp line-numbers">(sbcl)    (defparameter *x* (vector 1 2 3))

(sbcl)    (length *x*); 3
(sbcl)    (elt *x* 0) ; 1
(sbcl)    (elt *x* 1) ; 2
(sbcl)    (elt *x* 2) ; 3
(sbcl)    (elt *x* 3) ; error

(sbcl)    (setf (elt *x* 0) 10)
(sbcl)    *x*; #(10 2 3)
</code></pre>
    <br/>
    <br/>
    <li>Basic Sequence Functions</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Required Arguments</th>
                <th>Returns</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>COUNT</b></td>
                <td>Item and sequence.</td>
                <td>Number of times item appear in sequence.</td>
            </tr>
            <tr>
                <td><b>FIND</b></td>
                <td>Item and sequence.</td>
                <td>Item or <b>NIL</b></td>
            </tr>
            <tr>
                <td><b>POSITION</b></td>
                <td>Item and sequence.</td>
                <td>Index into sequence or <b>NIL</b> (0-indexed).</td>
            </tr>
            <tr>
                <td><b>REMOVE</b></td>
                <td>Item and sequence.</td>
                <td>Sequence with instances of item removed.</td>
            </tr>
            <tr>
                <td><b>SUBSTITUTE</b></td>
                <td>New-Item, item, and sequence.</td>
                <td>Sequence with instances of item replaced.</td>
            </tr>
        </tbody>
    </table>
    <br/>
<pre><code class="language-lisp line-numbers">(count 1 #(1 2 1 2 3 1 2 3 4))        ;		3
(remove 1 #(1 2 1 2 3 1 2 3 4))       ;		#(2 2 3 2 3 4)
(remove 1 '(1 2 1 2 3 1 2 3 4))       ;		(2 2 3 2 3 4)
(remove #\a "foobarbaz")              ;		"foobrbz"
(substitute 10 1 #(1 2 1 2 3 1 2 3 4));		#(10 2 10 2 3 10 2 3 4)
(substitute 10 1 '(1 2 1 2 3 1 2 3 4));		(10 2 10 2 3 10 2 3 4)
(substitute #\x #\b "foobarbaz")      ;		"fooxarxaz"
(find 1 #(1 2 1 2 3 1 2 3 4))         ;		1
(find 10 #(1 2 1 2 3 1 2 3 4))        ;		NIL
(position 1 #(1 2 1 2 3 1 2 3 4))     ;		0

(count "foo" #("foo" "bar" "baz") :test #'string=)   ; 1
(find 'c #((a 10) (b 20) (c 30) (d 40)) :key #'first); (C 30)

(find 'a #((a 10) (b 20) (a 30) (b 40)) :key #'first)            ; (A 10)
(find 'a #((a 10) (b 20) (a 30) (b 40)) :key #'first :from-end t); (A 30)

(remove #\a "foobarbaz" :count 1)            ; "foobrbaz"
(remove #\a "foobarbaz" :count 1 :from-end t); "foobarbz"

(count-if #'evenp #(1 2 3 4 5))        ; 2

(count-if-not #'evenp #(1 2 3 4 5))    ; 3

(position-if #'digit-char-p "abcd0001"); 4

(remove-if-not #'(lambda (x) (char= (elt x 0) #\f))
  #("foo" "bar" "baz" "foom"))
;; #("foo" "foom")

(remove-duplicates #(1 2 1 2 3 1 2 3 4))    ; #(1 2 3 4)

(concatenate 'vector #(1 2 3) '(4 5 6))     ; #(1 2 3 4 5 6)
(concatenate 'list #(1 2 3) '(4 5 6))       ; (1 2 3 4 5 6)
(concatenate 'string "abc" '(#\d #\e #\f))  ; "abcdef"

(merge 'vector #(1 3 5) #(2 4 6) #'&lt;)    ; #(1 2 3 4 5 6)
(merge 'list #(1 3 5) #(2 4 6) #'&lt;)      ; (1 2 3 4 5 6)

(subseq "foobarbaz" 3)                      ; "barbaz"
(subseq "foobarbaz" 3 6)                    ; "bar"



(defparameter *x* (copy-seq "foobarbaz"))

(setf (subseq *x* 3 6) "xxx")  ; subsequence and new value are same length
*x*
;; "fooxxxbaz"

(setf (subseq *x* 3 6) "abcd") ; new value too long, extra character ignored.
*x*
;; "fooabcbaz"

(setf (subseq *x* 3 6) "xx")   ; new value too short, only two characters changed
*x*
;; "fooxxcbaz"



(every #'evenp #(1 2 3 4 5))   ; NIL
(some #'evenp #(1 2 3 4 5))    ; T
(notany #'evenp #(1 2 3 4 5))  ; NIL
(notevery #'evenp #(1 2 3 4 5)); T



(map 'vector #'* #(1 2 3 4 5) #(10 9 8 7 6)); #(10 18 24 28 30)
(reduce #'+ #(1 2 3 4 5 6 7 8 9 10)); 55
</code></pre>
    <br/>
    <br/>
    <li>Standard Sequence Function Keyword Arguments</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Argument</th>
                <th>Meaning</th>
                <th>Default</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>:test</code></td>
                <td>Two-argument function used to compare item (or value extracted by <code>:key</code> function) to element.</td>
                <td><b>EQL</b></td>
            </tr>
            <tr>
                <td><code>:key</code></td>
                <td>One-argument function to extract key value from actual sequence element.<br/>
                    <b>NIL</b> means use element as is.</td>
                <td><b>NIL</b></td>
            </tr>
            <tr>
                <td><code>:start</code></td>
                <td>Starting index (inclusive) of subsequence.</td>
                <td><b>0</b></td>
            </tr>
            <tr>
                <td><code>:end</code></td>
                <td>Ending index (exclusive) of subsequence.<br/>
                    <b>NIL</b> indicates end of sequence.</td>
                <td><b>NIL</b></td>
            </tr>
            <tr>
                <td><code>:from-end</code></td>
                <td>If true, the sequence will be traversed in reverse order, from end to start.</td>
                <td><b>NIL</b></td>
            </tr>
            <tr>
                <td><code>:count</code></td>
                <td>Number indicating the number of elements to remove or substitute or <b>NIL</b> to indicate all (<b>REMOVE</b> and <b>SUBSTITUTE</b> only).</td>
                <td><b>NIL</b></td>
            </tr>
        </tbody>
    </table>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>CONS</h3>
<ol>
    <li>A cons cell is the fundamental 2-slot building block of Lisp lists.</li>
    <ul>
        <br/>
        <li>Slot1: <b>CAR</b> (the "first" thing)</li>
        <br/>
        <li>Slot2: <b>CDR</b> (the "rest" / tail pointer)</li>
    </ul>
    <br/>
    <br/>
    <li><code>(cons a d)</code> allocates a new cons cell whose <b>CAR</b> is <code>a</code> and <b>CDR</b> is <code>d</code>.</li>
<pre><code class="language-lisp line-numbers">(cons 1 2)          ; (1 . 2)   ;; an *improper* (dotted) pair
(cons 1 '(2 3))     ; (1 2 3)   ;; a proper list
(cons 'a 'b)        ; (A . B)
(cons '(a b) '(c d)); ((A B) C D)
</code></pre>
    <br/>
    <br/>
    <li>Proper vs. improper lists:</li>
    <ul>
        <br>
        <li>Proper list: chain of cons cells ending in NIL.<br/><br/>
            <code>(1 2 3)</code> is shorthand for <code>(1 . (2 . (3 . NIL)))</code>.</li>
        <br>
        <li>Improper list: CDR ends with a non-NIL atom.<br/><br/>
            <code>(1 . 2)</code> or <code>(1 2 . 3)</code>.</li>
    </ul>
    <br/>
    <br/>
    <br/>
    <li>Basic access: <code>CAR</code> and <code>CDR</code></li>
<pre><code class="language-lisp line-numbers">(car '(10 20 30)) ; 10
(cdr '(10 20 30)) ; (20 30)
(first '(10 20))  ; 10      ; synonyms: FIRST = CAR, REST = CDR
(rest  '(10 20))  ; (20)

(cadr  '(a b c))  ; B   ; = (car (cdr ...))
(caddr '(a b c d)); C



(cons 0 '(1 2 3))       ; (0 1 2 3)   ; O(1) prepend
(list 1 2 3)            ; (1 2 3)     ; constructs a fresh proper list
(list* 1 2 3)           ; (1 2 . 3)   ; last arg becomes the final CDR (can make improper)
(append '(1 2) '(3 4))  ; (1 2 3 4)   ; copies all but last list; O(n) in first arg



(let ((x (list 1 2 3)))
  (setf (car x) 99)     ; x =&gt; (99 2 3)
  (setf (cdr x) '(7))   ; x =&gt; (99 7)
  x)
</code></pre>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>SET, SEQ and SETF</h3>
<ol>
    <li>Overview</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Operator</th>
                <th>Type</th>
                <th>Evaluates 1st arg?</th>
                <th>Assigns to</th>
                <th>Works for</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>SETQ</code></td>
                <td>Special operator</td>
                <td class="hl-red-fg">No</td>
                <td>Lexical or special variables</td>
                <td>Variables only</td>
                <td>Fastest</td>
            </tr>
            <tr>
                <td><code>SETF</code></td>
                <td>Macro</td>
                <td class="hl-green-fg">Partially (place-specific)</td>
                <td>Generalized places</td>
                <td>Variables, array slots, struct slots, hash entries, accessors, ...</td>
                <td>Most general</td>
            </tr>
            <tr>
                <td><code>SET</code></td>
                <td>Function</td>
                <td class="hl-green-fg">Yes</td>
                <td>Global / special value cell of a symbol</td>
                <td>Symbols only</td>
                <td>Dynamic only; NEVER lexical</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <br/>
    <li><b>SETQ</b> does not evaluate the variable name, and works on lexical variables (from <code>let</code>) and special/global variables.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(let ((a 1))
  (setq a 2)   ; modifies lexical A
  a)
;; 2
</code></pre>
    <br/>
    <br/>
    <li><b>SETF</b> is designed to be the general assignment operator, and works on simple variables (like <code>setq</code>) and complex places.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(setf x 10)                     ; variable
(setf (car mylist) 3)           ; list cell
(setf (slot-value obj 'age) 25) ; CLOS slot
(setf (gethash 'a table) 9)     ; hash table key
(setf (aref arr 3) 22)          ; array
(setf my-struct-field 100)      ; accessor
</code></pre>
    <br/>
    <br/>
    <li><b>SET</b> evaluates its first argument and its result must be a symbol. It only modifies the symbol's global/special value, not lexicals.<br/><br/>
        Because it is a Function. Functions in Lisp evaluate all their arguments before the function is called.</li>
    <br/>
<pre><code class="language-lisp line-numbers">(set 'a 100)
a
;; 100


(let ((a 1))
  (set 'a 200))     ; Sets GLOBAL A, not this lexical A
a                   ; global A =&gt; 200


(let ((x 10))
  (set x 20))       ; ERROR: X holds 10, not a symbol




;; Global A
(set 'a 100)        ; sets global A = 100

(setq a 'b)         ; a now holds the symbol B
(set a 100)         ; sets global B = 100

(setq a 42)         ; replace `setq` here with `setf` is also ok.
(set a 100)         ; ERROR: 42 is not a symbol

(let ((a 1))
  (set 'a 999)      ; sets global A, lexical a still 1
  a)                ; 1
</code></pre>
    <br/>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Arrays (like in C / JS / TS)</h3>
<ol>
    <li>In Common Lisp, an <b>array</b> is a fixed-size, indexable collection of elements.<br/>
        It is similar to:
        <ul>
            <li>C: <code>int a[10];</code></li>
            <li>JS / TS: <code>const arr = [1, 2, 3];</code> (but JS arrays are dynamically sized)</li>
        </ul>
        In Lisp, <b>vectors</b> are just <u>one-dimensional arrays</u>. Here we focus on the general array features.
    </li>
    <br/>
    <br/>

    <li><b>Creating 1D Arrays</b> with <code>MAKE-ARRAY</code>:</li>
<pre><code class="language-lisp line-numbers">;; A 1D array of length 5, elements are unspecified, in SBCL it is treated as 0.
(defparameter *a* (make-array 5))

;; A 1D array of length 5, all elements start as 0
;; (defparameter *b* (make-array '(5) :initial-element 0))
(defparameter *b* (make-array 5 :initial-element 0))

*a*  ; =&gt; #(&lt;UNSPECIFIED&gt; &lt;UNSPECIFIED&gt; &lt;UNSPECIFIED&gt; &lt;UNSPECIFIED&gt; &lt;UNSPECIFIED&gt;)
*b*  ; =&gt; #(0 0 0 0 0)
</code></pre>
    <br/>
    <br/>

    <li><b>Array literal syntax</b> for 1D arrays (vectors):</li>
<pre><code class="language-lisp line-numbers">#(1 2 3)      ; vector of 3 elements
#("foo" "bar") ; vector of strings
</code></pre>
    <br/>
    <br/>

    <li><b>Accessing and modifying elements</b> with <code>AREF</code>:</li>
<pre><code class="language-lisp line-numbers">(defparameter *nums* (make-array 4 :initial-element 0))
; *NUMS* =&gt; #(0 0 0 0)

(aref *nums* 0)     ; =&gt; 0
(setf (aref *nums* 0) 42)
(aref *nums* 0)     ; =&gt; 42

(aref *nums* 3)     ; last valid index (0-based)
; (aref *nums* 4)   ; ERROR: index out of bounds
</code></pre>
    <br/>
    <br/>

    <li><b>Comparing to C / JS / TS</b> (informally):</li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Language</th>
                <th>Example</th>
                <th>Notes</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>C</td>
                <td><code>int a[4]; a[0] = 42;</code></td>
                <td>Fixed-size, contiguous memory.</td>
            </tr>
            <tr>
                <td>JS / TS</td>
                <td><code>const arr = [0, 0, 0, 0]; arr[0] = 42;</code></td>
                <td>Resizable, dynamic, can push/pop.</td>
            </tr>
            <tr>
                <td>Common Lisp</td>
                <td><code>(defparameter *a* (make-array 4 :initial-element 0))<br/>(setf (aref *a* 0) 42)</code></td>
                <td>By default fixed-size. Can also make adjustable arrays.</td>
            </tr>
        </tbody>
    </table>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Multi-Dimensional Arrays</h3>
<ol>
    <li>Common Lisp arrays can have <b>multiple dimensions</b>, like <code>int a[3][4];</code> in C.</li>
    <br/>
    <br/>

    <li>Use a <b>list of dimensions</b> with <code>MAKE-ARRAY</code>:</li>
<pre><code class="language-lisp line-numbers">;; 2 rows, 3 columns, all zeros
(defparameter *matrix* (make-array '(2 3) :initial-element 0))

*matrix*
;; =&gt; #2A((0 0 0)
;;        (0 0 0))
</code></pre>
    <br/>
    <br/>

    <li>Access elements with <code>AREF</code> using one index per dimension.</li>
<pre><code class="language-lisp line-numbers">(setf (aref *matrix* 0 0) 10)
(setf (aref *matrix* 0 1) 20)
(setf (aref *matrix* 1 2) 30)

*matrix*
;; =&gt; #2A((10 20 0)
;;        (0  0 30))

(aref *matrix* 1 2)  ; =&gt; 30
</code></pre>
    <br/>
    <br/>

    <li>Literal syntax for multi-dimensional arrays uses <code>#nA</code>:</li>
<pre><code class="language-lisp line-numbers">#2A((1 2 3)
    (4 5 6))
;; 2x3 array

#3A(((1 2) (3 4))
    ((5 6) (7 8)))
;; 3D array example
</code></pre>
    <br/>
    <br/>

    <li>Inspecting dimensions:</li>
<pre><code class="language-lisp line-numbers">(array-dimensions *matrix*) ; =&gt; (2 3)
(array-dimension *matrix* 0) ; =&gt; 2   ; rows
(array-dimension *matrix* 1) ; =&gt; 3   ; columns
</code></pre>
    <br/>
    <br/>

    <li>Iterating over a 2D array (like a matrix):</li>
<pre><code class="language-lisp line-numbers">(defun print-matrix (m)
  (destructuring-bind (rows cols) (array-dimensions m)
    (dotimes (i rows)
      (dotimes (j cols)
        (format t "~3A " (aref m i j)))
      (format t "~%"))))

(print-matrix *matrix*)
;; 10 20  0
;;  0  0 30
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3>Element Types and Specialized Arrays</h3>
<ol>
    <li>By default, arrays can hold any type (element type is <code>T</code>).<br/>
        You can restrict the <b>element type</b> for efficiency (implementation-dependent optimizations).
    </li>
    <br/>
    <br/>

    <li><b>Character array</b> (like a mutable string buffer):</li>
<pre><code class="language-lisp line-numbers">(defparameter *chars*
  (make-array 5 :element-type 'character
                :initial-element #\?))

*chars* ; =&gt; #(#\? #\? #\? #\? #\?)

(setf (aref *chars* 0) #\H)
(setf (aref *chars* 1) #\i)

*chars* ; =&gt; #(#\H #\i #\? #\? #\?)
</code></pre>
    <br/>
    <br/>

    <li><b>Numeric array</b>, e.g. <code>fixnum</code>:</li>
<pre><code class="language-lisp line-numbers">(defparameter *ints*
  (make-array 4 :element-type 'fixnum
                :initial-element 0))

(setf (aref *ints* 0) 10)
(setf (aref *ints* 1) 20)
*ints* ; =&gt; #(10 20 0 0)
</code></pre>
    <br/>
    <br/>

    <li>Element type does not change the <u>API</u> (you still use <code>aref</code> and <code>setf</code>),<br/>
        but can allow the implementation to store data more compactly (for example, like a C <code>int[]</code> or <code>char[]</code>).
    </li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3></h3>
<ol>
    <li></li>
    <br/>
    <br/>
    <li></li>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
